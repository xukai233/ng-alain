/* tslint:disable */
//----------------------
// <auto-generated>
//     Generated using the NSwag toolchain v11.20.1.0 (NJsonSchema v9.11.0.0 (Newtonsoft.Json v9.0.0.0)) (http://NSwag.org)
// </auto-generated>
//----------------------
// ReSharper disable InconsistentNaming

import { mergeMap as _observableMergeMap, catchError as _observableCatch } from 'rxjs/operators';
import { Observable, throwError as _observableThrow, of as _observableOf } from 'rxjs';
import { Injectable, Inject, Optional, InjectionToken } from '@angular/core';
import { HttpClient, HttpHeaders, HttpResponse, HttpResponseBase } from '@angular/common/http';

export const API_BASE_URL = new InjectionToken<string>('API_BASE_URL');

@Injectable()
export class PassportServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "http://langwenda.com:7000/mock/49";
    }

    /**
     * 验证用户合法
     * @param authenticateModel (optional) 
     * @return Success
     */
    authenticate(authenticateModel: AuthenticateModel | null | undefined): Observable<AuthenticateResultModel> {
        let url_ = this.baseUrl + "/passport/Authenticate";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(authenticateModel);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAuthenticate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAuthenticate(<any>response_);
                } catch (e) {
                    return <Observable<AuthenticateResultModel>><any>_observableThrow(e);
                }
            } else
                return <Observable<AuthenticateResultModel>><any>_observableThrow(response_);
        }));
    }

    protected processAuthenticate(response: HttpResponseBase): Observable<AuthenticateResultModel> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? AuthenticateResultModel.fromJS(resultData200) : new AuthenticateResultModel();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<AuthenticateResultModel>(<any>null);
    }
}

@Injectable()
export class AppServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "http://langwenda.com:7000/mock/49";
    }

    /**
     * 列出所有App
     * @return Success
     */
    listAll(): Observable<ListResultDtoOfAppDto> {
        let url_ = this.baseUrl + "/app/ListAll";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processListAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processListAll(<any>response_);
                } catch (e) {
                    return <Observable<ListResultDtoOfAppDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<ListResultDtoOfAppDto>><any>_observableThrow(response_);
        }));
    }

    protected processListAll(response: HttpResponseBase): Observable<ListResultDtoOfAppDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? ListResultDtoOfAppDto.fromJS(resultData200) : new ListResultDtoOfAppDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ListResultDtoOfAppDto>(<any>null);
    }

    /**
     * 授权租户App权限
     * @param updateTenantInputDto (optional) 
     * @return OK
     */
    authorizeTenant(updateTenantInputDto: AuthorizeTenantDto | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/app/AuthorizeTenant";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(updateTenantInputDto);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAuthorizeTenant(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAuthorizeTenant(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processAuthorizeTenant(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }
}

@Injectable()
export class TenantsServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "http://langwenda.com:7000/mock/49";
    }

    /**
     * 租户查询
     * @param filter (optional) 
     * @param tenantCode (optional) 
     * @param tenantName (optional) 
     * @param appId (optional) 
     * @param creationDateStart (optional) 
     * @param creationDateEnd (optional) 
     * @param pageIndex (optional) 
     * @param pageSize (optional) 
     * @return Success
     */
    list(filter: string | null | undefined, tenantCode: string | null | undefined, tenantName: string | null | undefined, appId: number | null | undefined, creationDateStart: number | null | undefined, creationDateEnd: number | null | undefined, pageIndex: number | null | undefined, pageSize: number | null | undefined): Observable<PagedResultDtoOfTenantListDto> {
        let url_ = this.baseUrl + "/tenants/List?";
        if (filter !== undefined)
            url_ += "filter=" + encodeURIComponent("" + filter) + "&"; 
        if (tenantCode !== undefined)
            url_ += "tenantCode=" + encodeURIComponent("" + tenantCode) + "&"; 
        if (tenantName !== undefined)
            url_ += "tenantName=" + encodeURIComponent("" + tenantName) + "&"; 
        if (appId !== undefined)
            url_ += "appId=" + encodeURIComponent("" + appId) + "&"; 
        if (creationDateStart !== undefined)
            url_ += "creationDateStart=" + encodeURIComponent("" + creationDateStart) + "&"; 
        if (creationDateEnd !== undefined)
            url_ += "creationDateEnd=" + encodeURIComponent("" + creationDateEnd) + "&"; 
        if (pageIndex !== undefined)
            url_ += "pageIndex=" + encodeURIComponent("" + pageIndex) + "&"; 
        if (pageSize !== undefined)
            url_ += "pageSize=" + encodeURIComponent("" + pageSize) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processList(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processList(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfTenantListDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfTenantListDto>><any>_observableThrow(response_);
        }));
    }

    protected processList(response: HttpResponseBase): Observable<PagedResultDtoOfTenantListDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? PagedResultDtoOfTenantListDto.fromJS(resultData200) : new PagedResultDtoOfTenantListDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfTenantListDto>(<any>null);
    }

    /**
     * 获取租户已授权的Apps
     * @param id (optional) 租户Id
     * @return Success
     */
    listTenantApps(id: number | null | undefined): Observable<ListResultDtoOfTenantAppsDto> {
        let url_ = this.baseUrl + "/tenants/ListTenantApps?";
        if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processListTenantApps(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processListTenantApps(<any>response_);
                } catch (e) {
                    return <Observable<ListResultDtoOfTenantAppsDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<ListResultDtoOfTenantAppsDto>><any>_observableThrow(response_);
        }));
    }

    protected processListTenantApps(response: HttpResponseBase): Observable<ListResultDtoOfTenantAppsDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? ListResultDtoOfTenantAppsDto.fromJS(resultData200) : new ListResultDtoOfTenantAppsDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ListResultDtoOfTenantAppsDto>(<any>null);
    }

    /**
     * 根据Id获取租户
     * @param id (optional) 租户Id
     * @return Success
     */
    getTenantById(id: number | null | undefined): Observable<TenantDto> {
        let url_ = this.baseUrl + "/tenants/GetTenantById?";
        if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetTenantById(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetTenantById(<any>response_);
                } catch (e) {
                    return <Observable<TenantDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<TenantDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetTenantById(response: HttpResponseBase): Observable<TenantDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? TenantDto.fromJS(resultData200) : new TenantDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<TenantDto>(<any>null);
    }

    /**
     * 租户开立
     * @param createTenantInputDto (optional) 
     * @return Success
     */
    new(createTenantInputDto: CreateTenantInputDto | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/tenants/New";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(createTenantInputDto);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processNew(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processNew(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processNew(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * 更新租户
     * @param updateTenantInputDto (optional) 
     * @return Success
     */
    update(updateTenantInputDto: TenantDto | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/tenants/Update";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(updateTenantInputDto);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdate(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processUpdate(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }
}

export enum AppStatus {
    InUse = "InUse", 
    NotInUse = "NotInUse", 
    Overdue = "Overdue", 
}

export class AuthorizeTenantDto implements IAuthorizeTenantDto {
    tenantId?: number | undefined;
    appId?: number | undefined;
    /** 基础功能 */
    basic?: boolean | undefined;
    /** 基础功能预期时间 */
    basicExpiryTime?: number | undefined;
    /** 付费功能 */
    pay?: boolean | undefined;
    /** 付费功能预期时间 */
    payExpiryTime?: number | undefined;

    constructor(data?: IAuthorizeTenantDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.tenantId = data["tenantId"];
            this.appId = data["appId"];
            this.basic = data["basic"];
            this.basicExpiryTime = data["basicExpiryTime"];
            this.pay = data["pay"];
            this.payExpiryTime = data["payExpiryTime"];
        }
    }

    static fromJS(data: any): AuthorizeTenantDto {
        data = typeof data === 'object' ? data : {};
        let result = new AuthorizeTenantDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["tenantId"] = this.tenantId;
        data["appId"] = this.appId;
        data["basic"] = this.basic;
        data["basicExpiryTime"] = this.basicExpiryTime;
        data["pay"] = this.pay;
        data["payExpiryTime"] = this.payExpiryTime;
        return data; 
    }
}

export interface IAuthorizeTenantDto {
    tenantId?: number | undefined;
    appId?: number | undefined;
    /** 基础功能 */
    basic?: boolean | undefined;
    /** 基础功能预期时间 */
    basicExpiryTime?: number | undefined;
    /** 付费功能 */
    pay?: boolean | undefined;
    /** 付费功能预期时间 */
    payExpiryTime?: number | undefined;
}

export class ListResultDtoOfTenantAppsDto implements IListResultDtoOfTenantAppsDto {
    tenant?: TenantDto | undefined;
    items?: AppDto[] | undefined;

    constructor(data?: IListResultDtoOfTenantAppsDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.tenant = data["tenant"] ? TenantDto.fromJS(data["tenant"]) : <any>undefined;
            if (data["items"] && data["items"].constructor === Array) {
                this.items = [];
                for (let item of data["items"])
                    this.items.push(AppDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ListResultDtoOfTenantAppsDto {
        data = typeof data === 'object' ? data : {};
        let result = new ListResultDtoOfTenantAppsDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["tenant"] = this.tenant ? this.tenant.toJSON() : <any>undefined;
        if (this.items && this.items.constructor === Array) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IListResultDtoOfTenantAppsDto {
    tenant?: TenantDto | undefined;
    items?: AppDto[] | undefined;
}

export class ListResultDtoOfAppDto implements IListResultDtoOfAppDto {
    items?: AppDto[] | undefined;

    constructor(data?: IListResultDtoOfAppDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            if (data["items"] && data["items"].constructor === Array) {
                this.items = [];
                for (let item of data["items"])
                    this.items.push(AppDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ListResultDtoOfAppDto {
        data = typeof data === 'object' ? data : {};
        let result = new ListResultDtoOfAppDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (this.items && this.items.constructor === Array) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IListResultDtoOfAppDto {
    items?: AppDto[] | undefined;
}

export class AppDto implements IAppDto {
    id?: number | undefined;
    appKey?: string | undefined;
    status?: AppStatus | undefined;
    /** 基础功能 */
    basic?: boolean | undefined;
    /** 基础功能预期时间 */
    basicExpiryTime?: number | undefined;
    /** 付费功能 */
    pay?: boolean | undefined;
    /** 付费功能预期时间 */
    payExpiryTime?: number | undefined;

    constructor(data?: IAppDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.appKey = data["appKey"];
            this.status = data["status"];
            this.basic = data["basic"];
            this.basicExpiryTime = data["basicExpiryTime"];
            this.pay = data["pay"];
            this.payExpiryTime = data["payExpiryTime"];
        }
    }

    static fromJS(data: any): AppDto {
        data = typeof data === 'object' ? data : {};
        let result = new AppDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["appKey"] = this.appKey;
        data["status"] = this.status;
        data["basic"] = this.basic;
        data["basicExpiryTime"] = this.basicExpiryTime;
        data["pay"] = this.pay;
        data["payExpiryTime"] = this.payExpiryTime;
        return data; 
    }
}

export interface IAppDto {
    id?: number | undefined;
    appKey?: string | undefined;
    status?: AppStatus | undefined;
    /** 基础功能 */
    basic?: boolean | undefined;
    /** 基础功能预期时间 */
    basicExpiryTime?: number | undefined;
    /** 付费功能 */
    pay?: boolean | undefined;
    /** 付费功能预期时间 */
    payExpiryTime?: number | undefined;
}

export class TenantDto implements ITenantDto {
    /** 租户key */
    id?: number | undefined;
    /** 租户名称 */
    tenantName?: string | undefined;
    /** 租户过期时间 */
    expiryTime?: number | undefined;
    /** 是否激活租户 */
    isActive?: boolean | undefined;

    constructor(data?: ITenantDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.tenantName = data["tenantName"];
            this.expiryTime = data["expiryTime"];
            this.isActive = data["isActive"];
        }
    }

    static fromJS(data: any): TenantDto {
        data = typeof data === 'object' ? data : {};
        let result = new TenantDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["tenantName"] = this.tenantName;
        data["expiryTime"] = this.expiryTime;
        data["isActive"] = this.isActive;
        return data; 
    }
}

export interface ITenantDto {
    /** 租户key */
    id?: number | undefined;
    /** 租户名称 */
    tenantName?: string | undefined;
    /** 租户过期时间 */
    expiryTime?: number | undefined;
    /** 是否激活租户 */
    isActive?: boolean | undefined;
}

export class CreateTenantInputDto implements ICreateTenantInputDto {
    /** 租户编号 */
    tenantCode!: string;
    /** 租户名称 */
    tenantName!: string;
    /** 租户描述 */
    tenantDesc?: string | undefined;
    /** 租户管理员邮箱 */
    adminEmail!: string;
    adminPassword!: string;
    /** 下次登录时密码重置 */
    shouldChangePasswordOnNextLogin?: string | undefined;
    /** 是否激活租户 */
    isActive?: boolean | undefined;
    /** 租户过期时间 */
    expiryTime?: number | undefined;

    constructor(data?: ICreateTenantInputDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.tenantCode = data["tenantCode"];
            this.tenantName = data["tenantName"];
            this.tenantDesc = data["tenantDesc"];
            this.adminEmail = data["adminEmail"];
            this.adminPassword = data["adminPassword"];
            this.shouldChangePasswordOnNextLogin = data["shouldChangePasswordOnNextLogin"];
            this.isActive = data["isActive"];
            this.expiryTime = data["expiryTime"];
        }
    }

    static fromJS(data: any): CreateTenantInputDto {
        data = typeof data === 'object' ? data : {};
        let result = new CreateTenantInputDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["tenantCode"] = this.tenantCode;
        data["tenantName"] = this.tenantName;
        data["tenantDesc"] = this.tenantDesc;
        data["adminEmail"] = this.adminEmail;
        data["adminPassword"] = this.adminPassword;
        data["shouldChangePasswordOnNextLogin"] = this.shouldChangePasswordOnNextLogin;
        data["isActive"] = this.isActive;
        data["expiryTime"] = this.expiryTime;
        return data; 
    }
}

export interface ICreateTenantInputDto {
    /** 租户编号 */
    tenantCode: string;
    /** 租户名称 */
    tenantName: string;
    /** 租户描述 */
    tenantDesc?: string | undefined;
    /** 租户管理员邮箱 */
    adminEmail: string;
    adminPassword: string;
    /** 下次登录时密码重置 */
    shouldChangePasswordOnNextLogin?: string | undefined;
    /** 是否激活租户 */
    isActive?: boolean | undefined;
    /** 租户过期时间 */
    expiryTime?: number | undefined;
}

export class PagedResultDtoOfTenantListDto implements IPagedResultDtoOfTenantListDto {
    totalCount?: number | undefined;
    items?: TenantListDto[] | undefined;

    constructor(data?: IPagedResultDtoOfTenantListDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.totalCount = data["totalCount"];
            if (data["items"] && data["items"].constructor === Array) {
                this.items = [];
                for (let item of data["items"])
                    this.items.push(TenantListDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfTenantListDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfTenantListDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (this.items && this.items.constructor === Array) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IPagedResultDtoOfTenantListDto {
    totalCount?: number | undefined;
    items?: TenantListDto[] | undefined;
}

export class TenantListDto implements ITenantListDto {
    id?: number | undefined;
    tenancyCode?: string | undefined;
    tenancyName?: string | undefined;
    isActive?: boolean | undefined;
    /** 创建时间 */
    creationTime?: number | undefined;
    /** 过期时间 */
    expiryTime?: number | undefined;

    constructor(data?: ITenantListDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.tenancyCode = data["tenancyCode"];
            this.tenancyName = data["tenancyName"];
            this.isActive = data["isActive"];
            this.creationTime = data["creationTime"];
            this.expiryTime = data["expiryTime"];
        }
    }

    static fromJS(data: any): TenantListDto {
        data = typeof data === 'object' ? data : {};
        let result = new TenantListDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["tenancyCode"] = this.tenancyCode;
        data["tenancyName"] = this.tenancyName;
        data["isActive"] = this.isActive;
        data["creationTime"] = this.creationTime;
        data["expiryTime"] = this.expiryTime;
        return data; 
    }
}

export interface ITenantListDto {
    id?: number | undefined;
    tenancyCode?: string | undefined;
    tenancyName?: string | undefined;
    isActive?: boolean | undefined;
    /** 创建时间 */
    creationTime?: number | undefined;
    /** 过期时间 */
    expiryTime?: number | undefined;
}

export class AuthenticateResultModel implements IAuthenticateResultModel {
    /** 授权Token */
    accessToken?: string | undefined;
    /** 有效时长 */
    expireInSeconds?: number | undefined;
    /** 是否需要重置密码 */
    shouldResetPassword?: boolean | undefined;
    /** 如果需要重置密码，生成ResetCode后返回前端 */
    passwordResetCode?: string | undefined;
    userId?: number | undefined;
    returnUrl?: string | undefined;

    constructor(data?: IAuthenticateResultModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.accessToken = data["accessToken"];
            this.expireInSeconds = data["expireInSeconds"];
            this.shouldResetPassword = data["shouldResetPassword"];
            this.passwordResetCode = data["passwordResetCode"];
            this.userId = data["userId"];
            this.returnUrl = data["returnUrl"];
        }
    }

    static fromJS(data: any): AuthenticateResultModel {
        data = typeof data === 'object' ? data : {};
        let result = new AuthenticateResultModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["accessToken"] = this.accessToken;
        data["expireInSeconds"] = this.expireInSeconds;
        data["shouldResetPassword"] = this.shouldResetPassword;
        data["passwordResetCode"] = this.passwordResetCode;
        data["userId"] = this.userId;
        data["returnUrl"] = this.returnUrl;
        return data; 
    }
}

export interface IAuthenticateResultModel {
    /** 授权Token */
    accessToken?: string | undefined;
    /** 有效时长 */
    expireInSeconds?: number | undefined;
    /** 是否需要重置密码 */
    shouldResetPassword?: boolean | undefined;
    /** 如果需要重置密码，生成ResetCode后返回前端 */
    passwordResetCode?: string | undefined;
    userId?: number | undefined;
    returnUrl?: string | undefined;
}

export class AuthenticateModel implements IAuthenticateModel {
    /** 用户名 */
    userName!: string;
    password!: string;
    rememberClient?: boolean | undefined;
    /** 未登录时访问的页面，登录后需要重定向 */
    returnUrl?: string | undefined;

    constructor(data?: IAuthenticateModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.userName = data["userName"];
            this.password = data["password"];
            this.rememberClient = data["rememberClient"];
            this.returnUrl = data["returnUrl"];
        }
    }

    static fromJS(data: any): AuthenticateModel {
        data = typeof data === 'object' ? data : {};
        let result = new AuthenticateModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["userName"] = this.userName;
        data["password"] = this.password;
        data["rememberClient"] = this.rememberClient;
        data["returnUrl"] = this.returnUrl;
        return data; 
    }
}

export interface IAuthenticateModel {
    /** 用户名 */
    userName: string;
    password: string;
    rememberClient?: boolean | undefined;
    /** 未登录时访问的页面，登录后需要重定向 */
    returnUrl?: string | undefined;
}

export class SwaggerException extends Error {
    message: string;
    status: number; 
    response: string; 
    headers: { [key: string]: any; };
    result: any; 

    constructor(message: string, status: number, response: string, headers: { [key: string]: any; }, result: any) {
        super();

        this.message = message;
        this.status = status;
        this.response = response;
        this.headers = headers;
        this.result = result;
    }

    protected isSwaggerException = true;

    static isSwaggerException(obj: any): obj is SwaggerException {
        return obj.isSwaggerException === true;
    }
}

function throwException(message: string, status: number, response: string, headers: { [key: string]: any; }, result?: any): Observable<any> {
    if(result !== null && result !== undefined)
        return _observableThrow(result);
    else
        return _observableThrow(new SwaggerException(message, status, response, headers, null));
}

function blobToText(blob: any): Observable<string> {
    return new Observable<string>((observer: any) => {
        if (!blob) {
            observer.next("");
            observer.complete();
        } else {
            let reader = new FileReader(); 
            reader.onload = function() { 
                observer.next(this.result);
                observer.complete();
            }
            reader.readAsText(blob); 
        }
    });
}