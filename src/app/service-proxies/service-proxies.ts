/* tslint:disable */
//----------------------
// <auto-generated>
//     Generated using the NSwag toolchain v12.0.1.0 (NJsonSchema v9.12.3.0 (Newtonsoft.Json v11.0.0.0)) (http://NSwag.org)
// </auto-generated>
//----------------------
// ReSharper disable InconsistentNaming

import { mergeMap as _observableMergeMap, catchError as _observableCatch } from 'rxjs/operators';
import { Observable, throwError as _observableThrow, of as _observableOf } from 'rxjs';
import { Injectable, Inject, Optional, InjectionToken } from '@angular/core';
import { HttpClient, HttpHeaders, HttpResponse, HttpResponseBase } from '@angular/common/http';

export const API_BASE_URL = new InjectionToken<string>('API_BASE_URL');

@Injectable()
export class PassportServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "http://langwenda.com:7000/mock/58";
    }

    /**
     * 验证用户合法
     * @param authenticateModel (optional) 
     * @return Success
     */
    authenticate(authenticateModel: AuthenticateModel | null | undefined): Observable<AuthenticateResultModel> {
        let url_ = this.baseUrl + "/passport/authenticate";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(authenticateModel);
        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAuthenticate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAuthenticate(<any>response_);
                } catch (e) {
                    return <Observable<AuthenticateResultModel>><any>_observableThrow(e);
                }
            } else
                return <Observable<AuthenticateResultModel>><any>_observableThrow(response_);
        }));
    }

    protected processAuthenticate(response: HttpResponseBase): Observable<AuthenticateResultModel> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? AuthenticateResultModel.fromJS(resultData200) : new AuthenticateResultModel();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<AuthenticateResultModel>(<any>null);
    }
}

@Injectable()
export class AppServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "http://langwenda.com:7000/mock/58";
    }

    /**
     * 列出所有App
     * @return Success
     */
    listAll(): Observable<ListResultDtoOfAppDto> {
        let url_ = this.baseUrl + "/app/all";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processListAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processListAll(<any>response_);
                } catch (e) {
                    return <Observable<ListResultDtoOfAppDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<ListResultDtoOfAppDto>><any>_observableThrow(response_);
        }));
    }

    protected processListAll(response: HttpResponseBase): Observable<ListResultDtoOfAppDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? ListResultDtoOfAppDto.fromJS(resultData200) : new ListResultDtoOfAppDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ListResultDtoOfAppDto>(<any>null);
    }

    /**
     * 列出特定租户下的所有App
     * @param tenantId 需要获得App的租户Id
     * @return Success
     */
    findByTenant(tenantId: number): Observable<TenantAppsDto> {
        let url_ = this.baseUrl + "/app/find-by-tenant/{tenantId}";
        if (tenantId === undefined || tenantId === null)
            throw new Error("The parameter 'tenantId' must be defined.");
        url_ = url_.replace("{tenantId}", encodeURIComponent("" + tenantId)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processFindByTenant(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processFindByTenant(<any>response_);
                } catch (e) {
                    return <Observable<TenantAppsDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<TenantAppsDto>><any>_observableThrow(response_);
        }));
    }

    protected processFindByTenant(response: HttpResponseBase): Observable<TenantAppsDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? TenantAppsDto.fromJS(resultData200) : new TenantAppsDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<TenantAppsDto>(<any>null);
    }

    /**
     * 授权租户App权限
     * @param createTenantDto (optional) 
     * @return OK
     */
    addAuthorize(createTenantDto: AuthorizeTenantDto | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/app/authorize";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(createTenantDto);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAddAuthorize(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAddAuthorize(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processAddAuthorize(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * 更新租户App权限
     * @param updateTenantDto (optional) 
     * @return OK
     */
    updateAuthorize(updateTenantDto: AuthorizeTenantDto | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/app/authorize";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(updateTenantDto);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateAuthorize(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateAuthorize(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processUpdateAuthorize(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }
}

@Injectable()
export class TenantServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "http://langwenda.com:7000/mock/58";
    }

    /**
     * 租户查询
     * @param filterTenants (optional) 按照查询条件过滤租户
     * @return Success
     */
    list(filterTenants: FilterTenantsDto | null | undefined): Observable<PagedResultDtoOfTenantListDto> {
        let url_ = this.baseUrl + "/tenant/searches";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(filterTenants);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processList(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processList(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfTenantListDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfTenantListDto>><any>_observableThrow(response_);
        }));
    }

    protected processList(response: HttpResponseBase): Observable<PagedResultDtoOfTenantListDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? PagedResultDtoOfTenantListDto.fromJS(resultData200) : new PagedResultDtoOfTenantListDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfTenantListDto>(<any>null);
    }

    /**
     * 租户开立
     * @param createTenantDto (optional) 
     * @return Success
     */
    add(createTenantDto: CreateTenantDto | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/tenant";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(createTenantDto);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAdd(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAdd(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processAdd(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * 根据Id获取租户
     * @param tenantId 租户Id
     * @return Success
     */
    get(tenantId: number): Observable<TenantDto> {
        let url_ = this.baseUrl + "/tenant/{tenantId}";
        if (tenantId === undefined || tenantId === null)
            throw new Error("The parameter 'tenantId' must be defined.");
        url_ = url_.replace("{tenantId}", encodeURIComponent("" + tenantId)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGet(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGet(<any>response_);
                } catch (e) {
                    return <Observable<TenantDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<TenantDto>><any>_observableThrow(response_);
        }));
    }

    protected processGet(response: HttpResponseBase): Observable<TenantDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? TenantDto.fromJS(resultData200) : new TenantDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<TenantDto>(<any>null);
    }

    /**
     * 更新租户
     * @param tenantId 租户Id
     * @param updateTenantDto (optional) 
     * @return Success
     */
    update(tenantId: number, updateTenantDto: UpdateTenantDto | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/tenant/{tenantId}";
        if (tenantId === undefined || tenantId === null)
            throw new Error("The parameter 'tenantId' must be defined.");
        url_ = url_.replace("{tenantId}", encodeURIComponent("" + tenantId)); 
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(updateTenantDto);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdate(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processUpdate(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }
}

@Injectable()
export class AccountServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "http://langwenda.com:7000/mock/58";
    }

    /**
     * 账户查询
     * @param filterAccounts (optional) 按照查询条件过滤租户
     * @return Success
     */
    list(filterAccounts: FilterAccountsDto | null | undefined): Observable<PagedResultDtoOfAccountsListDto> {
        let url_ = this.baseUrl + "/account/searches";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(filterAccounts);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processList(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processList(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfAccountsListDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfAccountsListDto>><any>_observableThrow(response_);
        }));
    }

    protected processList(response: HttpResponseBase): Observable<PagedResultDtoOfAccountsListDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? PagedResultDtoOfAccountsListDto.fromJS(resultData200) : new PagedResultDtoOfAccountsListDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfAccountsListDto>(<any>null);
    }

    /**
     * 建立账户
     * @param createAccount (optional) 新建账户
     * @return Success
     */
    add(createAccount: CreateAccountDto | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/account";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(createAccount);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAdd(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAdd(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processAdd(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * 更新账户
     * @param accountId 账户Id
     * @param updateAccount (optional) 更新账户
     * @return Succes
     */
    update(accountId: number, updateAccount: UpdateAccountDto | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/account";
        if (accountId === undefined || accountId === null)
            throw new Error("The parameter 'accountId' must be defined.");
        url_ = url_.replace("{accountId}", encodeURIComponent("" + accountId)); 
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(updateAccount);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdate(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processUpdate(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * 删除账户
     * @param accountId 账户Id
     * @return Succes
     */
    delete(accountId: number): Observable<void> {
        let url_ = this.baseUrl + "/account/{accountId}";
        if (accountId === undefined || accountId === null)
            throw new Error("The parameter 'accountId' must be defined.");
        url_ = url_.replace("{accountId}", encodeURIComponent("" + accountId)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * 上传头像
     * @param accountId ID of Account to update
     * @param additionalMetadata (optional) Additional data to pass to server
     * @param file (optional) file to upload
     * @return successful operation
     */
    uploadImage(accountId: number, additionalMetadata: string | null | undefined, file: FileParameter | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/account/{accountId}/upload-image";
        if (accountId === undefined || accountId === null)
            throw new Error("The parameter 'accountId' must be defined.");
        url_ = url_.replace("{accountId}", encodeURIComponent("" + accountId)); 
        url_ = url_.replace(/[?&]$/, "");

        const content_ = new FormData();
        if (additionalMetadata !== null && additionalMetadata !== undefined)
            content_.append("additionalMetadata", additionalMetadata.toString());
        if (file !== null && file !== undefined)
            content_.append("file", file.data, file.fileName ? file.fileName : "file");

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUploadImage(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUploadImage(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processUploadImage(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * 新建账户组
     * @param createAccountGroup (optional) 
     * @return Success
     */
    add2(createAccountGroup: CreateAccountGroupDto | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/account-group";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(createAccountGroup);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAdd2(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAdd2(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processAdd2(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }
}

@Injectable()
export class AccountGroupServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "http://langwenda.com:7000/mock/58";
    }

    /**
     * 账户组查询
     * @return Success
     */
    list(): Observable<ListResultDtoOfAccountGroupDto> {
        let url_ = this.baseUrl + "/account-group/all";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processList(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processList(<any>response_);
                } catch (e) {
                    return <Observable<ListResultDtoOfAccountGroupDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<ListResultDtoOfAccountGroupDto>><any>_observableThrow(response_);
        }));
    }

    protected processList(response: HttpResponseBase): Observable<ListResultDtoOfAccountGroupDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? ListResultDtoOfAccountGroupDto.fromJS(resultData200) : new ListResultDtoOfAccountGroupDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ListResultDtoOfAccountGroupDto>(<any>null);
    }

    /**
     * 更新账户组
     * @param accountGroupId 账户组Id
     * @param updateAccountGroup (optional) 更新账户组
     * @return Succes
     */
    update(accountGroupId: number, updateAccountGroup: UpdateAccountGroupDto | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/account-group/{accountGroupId}";
        if (accountGroupId === undefined || accountGroupId === null)
            throw new Error("The parameter 'accountGroupId' must be defined.");
        url_ = url_.replace("{accountGroupId}", encodeURIComponent("" + accountGroupId)); 
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(updateAccountGroup);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdate(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processUpdate(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * 删除账户组
     * @param accountGroupId 账户组Id
     * @return Succes
     */
    delete(accountGroupId: number): Observable<void> {
        let url_ = this.baseUrl + "/account-group/{accountGroupId}";
        if (accountGroupId === undefined || accountGroupId === null)
            throw new Error("The parameter 'accountGroupId' must be defined.");
        url_ = url_.replace("{accountGroupId}", encodeURIComponent("" + accountGroupId)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }
}

@Injectable()
export class AuditLogServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "http://langwenda.com:7000/mock/58";
    }

    /**
     * 审计日志查询
     * @param filterAuditLogs (optional) 按照查询条件过滤审计日志
     * @return Success
     */
    list(filterAuditLogs: FilterAuditLogsDto | null | undefined): Observable<PagedResultDtoOfAuditLogsListDto> {
        let url_ = this.baseUrl + "/audit-log/searches";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(filterAuditLogs);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processList(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processList(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfAuditLogsListDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfAuditLogsListDto>><any>_observableThrow(response_);
        }));
    }

    protected processList(response: HttpResponseBase): Observable<PagedResultDtoOfAuditLogsListDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? PagedResultDtoOfAuditLogsListDto.fromJS(resultData200) : new PagedResultDtoOfAuditLogsListDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfAuditLogsListDto>(<any>null);
    }
}

@Injectable()
export class PermissionServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "http://langwenda.com:7000/mock/58";
    }

    /**
     * 列出所有权限
     * @return Success
     */
    listAll(): Observable<ListResultDtoOfPermissionDto> {
        let url_ = this.baseUrl + "/permission/all";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processListAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processListAll(<any>response_);
                } catch (e) {
                    return <Observable<ListResultDtoOfPermissionDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<ListResultDtoOfPermissionDto>><any>_observableThrow(response_);
        }));
    }

    protected processListAll(response: HttpResponseBase): Observable<ListResultDtoOfPermissionDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? ListResultDtoOfPermissionDto.fromJS(resultData200) : new ListResultDtoOfPermissionDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ListResultDtoOfPermissionDto>(<any>null);
    }

    /**
     * 列出用户组的所有权限
     * @param accountGroupId 账户组Id
     * @return Success
     */
    listByAccountGroupId(accountGroupId: number): Observable<ListResultDtoOfPermissionDto> {
        let url_ = this.baseUrl + "/permission/account-group/{accountGroupId}";
        if (accountGroupId === undefined || accountGroupId === null)
            throw new Error("The parameter 'accountGroupId' must be defined.");
        url_ = url_.replace("{accountGroupId}", encodeURIComponent("" + accountGroupId)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processListByAccountGroupId(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processListByAccountGroupId(<any>response_);
                } catch (e) {
                    return <Observable<ListResultDtoOfPermissionDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<ListResultDtoOfPermissionDto>><any>_observableThrow(response_);
        }));
    }

    protected processListByAccountGroupId(response: HttpResponseBase): Observable<ListResultDtoOfPermissionDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? ListResultDtoOfPermissionDto.fromJS(resultData200) : new ListResultDtoOfPermissionDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ListResultDtoOfPermissionDto>(<any>null);
    }

    /**
     * 更新用户组的所有权限
     * @param accountGroupId 账户组Id
     * @param updateAccountGroupPermission (optional) 更新账户组权限
     * @return Success
     */
    updateAccountGroupPermissions(accountGroupId: number, updateAccountGroupPermission: GrantedPermissionsDto | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/permission/account-group/{accountGroupId}";
        if (accountGroupId === undefined || accountGroupId === null)
            throw new Error("The parameter 'accountGroupId' must be defined.");
        url_ = url_.replace("{accountGroupId}", encodeURIComponent("" + accountGroupId)); 
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(updateAccountGroupPermission);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateAccountGroupPermissions(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateAccountGroupPermissions(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processUpdateAccountGroupPermissions(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * 列出用户的所有权限
     * @param accountId 账户Id
     * @return Success
     */
    listByAccountId(accountId: number): Observable<ListResultDtoOfPermissionDto> {
        let url_ = this.baseUrl + "/permission/account/{accountId}";
        if (accountId === undefined || accountId === null)
            throw new Error("The parameter 'accountId' must be defined.");
        url_ = url_.replace("{accountId}", encodeURIComponent("" + accountId)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processListByAccountId(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processListByAccountId(<any>response_);
                } catch (e) {
                    return <Observable<ListResultDtoOfPermissionDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<ListResultDtoOfPermissionDto>><any>_observableThrow(response_);
        }));
    }

    protected processListByAccountId(response: HttpResponseBase): Observable<ListResultDtoOfPermissionDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? ListResultDtoOfPermissionDto.fromJS(resultData200) : new ListResultDtoOfPermissionDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ListResultDtoOfPermissionDto>(<any>null);
    }

    /**
     * 更新用户组的所有权限
     * @param accountId 账户Id
     * @param updateAccountPermission (optional) 更新账户权限
     * @return Success
     */
    updateAccountPermissions(accountId: number, updateAccountPermission: GrantedPermissionsDto | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/permission/account/{accountId}";
        if (accountId === undefined || accountId === null)
            throw new Error("The parameter 'accountId' must be defined.");
        url_ = url_.replace("{accountId}", encodeURIComponent("" + accountId)); 
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(updateAccountPermission);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateAccountPermissions(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateAccountPermissions(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processUpdateAccountPermissions(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }
}

@Injectable()
export class SettingsServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "http://langwenda.com:7000/mock/58";
    }

    /**
     * 列出租户的所有设定
     * @return Success
     */
    listAll(): Observable<SettingsDto> {
        let url_ = this.baseUrl + "/settings/all";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processListAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processListAll(<any>response_);
                } catch (e) {
                    return <Observable<SettingsDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<SettingsDto>><any>_observableThrow(response_);
        }));
    }

    protected processListAll(response: HttpResponseBase): Observable<SettingsDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? SettingsDto.fromJS(resultData200) : new SettingsDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SettingsDto>(<any>null);
    }

    /**
     * 更新租户的所有设定
     * @param updateTenantAllSettings (optional) 更新账户组权限
     * @return Success
     */
    updateAll(updateTenantAllSettings: SettingsDto | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/settings/all";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(updateTenantAllSettings);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateAll(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processUpdateAll(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }
}

export class SettingsDto implements ISettingsDto {
    logo?: string | undefined;
    themeColor?: string | undefined;
    defalutMenuState?: string | undefined;

    constructor(data?: ISettingsDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.logo = data["logo"];
            this.themeColor = data["themeColor"];
            this.defalutMenuState = data["defalutMenuState"];
        }
    }

    static fromJS(data: any): SettingsDto {
        data = typeof data === 'object' ? data : {};
        let result = new SettingsDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["logo"] = this.logo;
        data["themeColor"] = this.themeColor;
        data["defalutMenuState"] = this.defalutMenuState;
        return data; 
    }
}

export interface ISettingsDto {
    logo?: string | undefined;
    themeColor?: string | undefined;
    defalutMenuState?: string | undefined;
}

export class GrantedPermissionsDto implements IGrantedPermissionsDto {
    ids?: number[] | undefined;

    constructor(data?: IGrantedPermissionsDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            if (data["ids"] && data["ids"].constructor === Array) {
                this.ids = [];
                for (let item of data["ids"])
                    this.ids.push(item);
            }
        }
    }

    static fromJS(data: any): GrantedPermissionsDto {
        data = typeof data === 'object' ? data : {};
        let result = new GrantedPermissionsDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (this.ids && this.ids.constructor === Array) {
            data["ids"] = [];
            for (let item of this.ids)
                data["ids"].push(item);
        }
        return data; 
    }
}

export interface IGrantedPermissionsDto {
    ids?: number[] | undefined;
}

export class PermissionDto implements IPermissionDto {
    id?: number | undefined;
    level?: number | undefined;
    parentId?: number | undefined;
    displayName?: string | undefined;
    desc?: string | undefined;

    constructor(data?: IPermissionDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.level = data["level"];
            this.parentId = data["parentId"];
            this.displayName = data["displayName"];
            this.desc = data["desc"];
        }
    }

    static fromJS(data: any): PermissionDto {
        data = typeof data === 'object' ? data : {};
        let result = new PermissionDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["level"] = this.level;
        data["parentId"] = this.parentId;
        data["displayName"] = this.displayName;
        data["desc"] = this.desc;
        return data; 
    }
}

export interface IPermissionDto {
    id?: number | undefined;
    level?: number | undefined;
    parentId?: number | undefined;
    displayName?: string | undefined;
    desc?: string | undefined;
}

export class ListResultDtoOfPermissionDto implements IListResultDtoOfPermissionDto {
    items?: PermissionDto[] | undefined;

    constructor(data?: IListResultDtoOfPermissionDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            if (data["items"] && data["items"].constructor === Array) {
                this.items = [];
                for (let item of data["items"])
                    this.items.push(PermissionDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ListResultDtoOfPermissionDto {
        data = typeof data === 'object' ? data : {};
        let result = new ListResultDtoOfPermissionDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (this.items && this.items.constructor === Array) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IListResultDtoOfPermissionDto {
    items?: PermissionDto[] | undefined;
}

export class FilterAuditLogsDto implements IFilterAuditLogsDto {
    /** 创建时间从 */
    createTimeFrom?: number | undefined;
    /** 创建时间到 */
    createTimeEnd?: number | undefined;
    timeOfDurationFrom?: number | undefined;
    timeOfDurationEnd?: number | undefined;
    status?: string | undefined;
    account?: string | undefined;

    constructor(data?: IFilterAuditLogsDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.createTimeFrom = data["createTimeFrom"];
            this.createTimeEnd = data["createTimeEnd"];
            this.timeOfDurationFrom = data["timeOfDurationFrom"];
            this.timeOfDurationEnd = data["timeOfDurationEnd"];
            this.status = data["status"];
            this.account = data["account"];
        }
    }

    static fromJS(data: any): FilterAuditLogsDto {
        data = typeof data === 'object' ? data : {};
        let result = new FilterAuditLogsDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["createTimeFrom"] = this.createTimeFrom;
        data["createTimeEnd"] = this.createTimeEnd;
        data["timeOfDurationFrom"] = this.timeOfDurationFrom;
        data["timeOfDurationEnd"] = this.timeOfDurationEnd;
        data["status"] = this.status;
        data["account"] = this.account;
        return data; 
    }
}

export interface IFilterAuditLogsDto {
    /** 创建时间从 */
    createTimeFrom?: number | undefined;
    /** 创建时间到 */
    createTimeEnd?: number | undefined;
    timeOfDurationFrom?: number | undefined;
    timeOfDurationEnd?: number | undefined;
    status?: string | undefined;
    account?: string | undefined;
}

export class AuditLogsListDto implements IAuditLogsListDto {
    id?: number | undefined;
    account?: string | undefined;
    app?: string | undefined;
    api?: string | undefined;
    status?: string | undefined;
    createTime?: number | undefined;
    timeOfDuration?: number | undefined;
    ip?: string | undefined;
    client?: string | undefined;

    constructor(data?: IAuditLogsListDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.account = data["account"];
            this.app = data["app"];
            this.api = data["api"];
            this.status = data["status"];
            this.createTime = data["createTime"];
            this.timeOfDuration = data["timeOfDuration"];
            this.ip = data["ip"];
            this.client = data["client"];
        }
    }

    static fromJS(data: any): AuditLogsListDto {
        data = typeof data === 'object' ? data : {};
        let result = new AuditLogsListDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["account"] = this.account;
        data["app"] = this.app;
        data["api"] = this.api;
        data["status"] = this.status;
        data["createTime"] = this.createTime;
        data["timeOfDuration"] = this.timeOfDuration;
        data["ip"] = this.ip;
        data["client"] = this.client;
        return data; 
    }
}

export interface IAuditLogsListDto {
    id?: number | undefined;
    account?: string | undefined;
    app?: string | undefined;
    api?: string | undefined;
    status?: string | undefined;
    createTime?: number | undefined;
    timeOfDuration?: number | undefined;
    ip?: string | undefined;
    client?: string | undefined;
}

export class PagedResultDtoOfAuditLogsListDto implements IPagedResultDtoOfAuditLogsListDto {
    totalCount?: number | undefined;
    items?: AuditLogsListDto[] | undefined;

    constructor(data?: IPagedResultDtoOfAuditLogsListDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.totalCount = data["totalCount"];
            if (data["items"] && data["items"].constructor === Array) {
                this.items = [];
                for (let item of data["items"])
                    this.items.push(AuditLogsListDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfAuditLogsListDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfAuditLogsListDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (this.items && this.items.constructor === Array) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IPagedResultDtoOfAuditLogsListDto {
    totalCount?: number | undefined;
    items?: AuditLogsListDto[] | undefined;
}

export class AccountDto implements IAccountDto {
    id?: number | undefined;
    /** 账户编号 */
    code?: string | undefined;
    /** 账户名称 */
    displayName?: string | undefined;
    /** 邮箱 */
    email?: string | undefined;
    /** 账户是否启用 */
    isActive?: boolean | undefined;
    /** 创建时间 */
    createTime?: number | undefined;

    constructor(data?: IAccountDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.code = data["code"];
            this.displayName = data["displayName"];
            this.email = data["email"];
            this.isActive = data["isActive"];
            this.createTime = data["createTime"];
        }
    }

    static fromJS(data: any): AccountDto {
        data = typeof data === 'object' ? data : {};
        let result = new AccountDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["code"] = this.code;
        data["displayName"] = this.displayName;
        data["email"] = this.email;
        data["isActive"] = this.isActive;
        data["createTime"] = this.createTime;
        return data; 
    }
}

export interface IAccountDto {
    id?: number | undefined;
    /** 账户编号 */
    code?: string | undefined;
    /** 账户名称 */
    displayName?: string | undefined;
    /** 邮箱 */
    email?: string | undefined;
    /** 账户是否启用 */
    isActive?: boolean | undefined;
    /** 创建时间 */
    createTime?: number | undefined;
}

export class FilterAccountsDto implements IFilterAccountsDto {
    /** 综合过滤，by name or code */
    filter?: string | undefined;
    accountGroupId?: number | undefined;

    constructor(data?: IFilterAccountsDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.filter = data["filter"];
            this.accountGroupId = data["accountGroupId"];
        }
    }

    static fromJS(data: any): FilterAccountsDto {
        data = typeof data === 'object' ? data : {};
        let result = new FilterAccountsDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["filter"] = this.filter;
        data["accountGroupId"] = this.accountGroupId;
        return data; 
    }
}

export interface IFilterAccountsDto {
    /** 综合过滤，by name or code */
    filter?: string | undefined;
    accountGroupId?: number | undefined;
}

export class CreateAccountDto implements ICreateAccountDto {
    /** 账户编号 */
    code?: string | undefined;
    /** 账户名称 */
    displayName?: string | undefined;
    password?: string | undefined;
    /** 下次登录需要修改密码 */
    needChangePasswordInNextLogin?: boolean | undefined;
    /** 邮箱 */
    email?: string | undefined;
    /** 账户是否启用 */
    isActive?: boolean | undefined;
    accountGourps?: AccountGroupDto[] | undefined;

    constructor(data?: ICreateAccountDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.code = data["code"];
            this.displayName = data["displayName"];
            this.password = data["password"];
            this.needChangePasswordInNextLogin = data["needChangePasswordInNextLogin"];
            this.email = data["email"];
            this.isActive = data["isActive"];
            if (data["accountGourps"] && data["accountGourps"].constructor === Array) {
                this.accountGourps = [];
                for (let item of data["accountGourps"])
                    this.accountGourps.push(AccountGroupDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): CreateAccountDto {
        data = typeof data === 'object' ? data : {};
        let result = new CreateAccountDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["code"] = this.code;
        data["displayName"] = this.displayName;
        data["password"] = this.password;
        data["needChangePasswordInNextLogin"] = this.needChangePasswordInNextLogin;
        data["email"] = this.email;
        data["isActive"] = this.isActive;
        if (this.accountGourps && this.accountGourps.constructor === Array) {
            data["accountGourps"] = [];
            for (let item of this.accountGourps)
                data["accountGourps"].push(item.toJSON());
        }
        return data; 
    }
}

export interface ICreateAccountDto {
    /** 账户编号 */
    code?: string | undefined;
    /** 账户名称 */
    displayName?: string | undefined;
    password?: string | undefined;
    /** 下次登录需要修改密码 */
    needChangePasswordInNextLogin?: boolean | undefined;
    /** 邮箱 */
    email?: string | undefined;
    /** 账户是否启用 */
    isActive?: boolean | undefined;
    accountGourps?: AccountGroupDto[] | undefined;
}

export class UpdateAccountDto implements IUpdateAccountDto {
    /** 账户Key */
    id?: number | undefined;
    /** 账户名称 */
    displayName?: string | undefined;
    /** 邮箱 */
    email?: string | undefined;
    /** 账户是否启用 */
    isActive?: boolean | undefined;
    accountGourps?: AccountGroupDto[] | undefined;

    constructor(data?: IUpdateAccountDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.displayName = data["displayName"];
            this.email = data["email"];
            this.isActive = data["isActive"];
            if (data["accountGourps"] && data["accountGourps"].constructor === Array) {
                this.accountGourps = [];
                for (let item of data["accountGourps"])
                    this.accountGourps.push(AccountGroupDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): UpdateAccountDto {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateAccountDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["displayName"] = this.displayName;
        data["email"] = this.email;
        data["isActive"] = this.isActive;
        if (this.accountGourps && this.accountGourps.constructor === Array) {
            data["accountGourps"] = [];
            for (let item of this.accountGourps)
                data["accountGourps"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IUpdateAccountDto {
    /** 账户Key */
    id?: number | undefined;
    /** 账户名称 */
    displayName?: string | undefined;
    /** 邮箱 */
    email?: string | undefined;
    /** 账户是否启用 */
    isActive?: boolean | undefined;
    accountGourps?: AccountGroupDto[] | undefined;
}

export class AccountListDto implements IAccountListDto {
    id?: number | undefined;
    /** 账户编号 */
    code?: string | undefined;
    /** 账户名称 */
    displayName?: string | undefined;
    /** 邮箱 */
    email?: string | undefined;
    /** 账户是否启用 */
    isActive?: boolean | undefined;
    /** 上次登录时间 */
    lastLoginTime?: number | undefined;
    /** 创建时间 */
    createTime?: number | undefined;

    constructor(data?: IAccountListDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.code = data["code"];
            this.displayName = data["displayName"];
            this.email = data["email"];
            this.isActive = data["isActive"];
            this.lastLoginTime = data["lastLoginTime"];
            this.createTime = data["createTime"];
        }
    }

    static fromJS(data: any): AccountListDto {
        data = typeof data === 'object' ? data : {};
        let result = new AccountListDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["code"] = this.code;
        data["displayName"] = this.displayName;
        data["email"] = this.email;
        data["isActive"] = this.isActive;
        data["lastLoginTime"] = this.lastLoginTime;
        data["createTime"] = this.createTime;
        return data; 
    }
}

export interface IAccountListDto {
    id?: number | undefined;
    /** 账户编号 */
    code?: string | undefined;
    /** 账户名称 */
    displayName?: string | undefined;
    /** 邮箱 */
    email?: string | undefined;
    /** 账户是否启用 */
    isActive?: boolean | undefined;
    /** 上次登录时间 */
    lastLoginTime?: number | undefined;
    /** 创建时间 */
    createTime?: number | undefined;
}

export class PagedResultDtoOfAccountsListDto implements IPagedResultDtoOfAccountsListDto {
    totalCount?: number | undefined;
    items?: AccountListDto[] | undefined;

    constructor(data?: IPagedResultDtoOfAccountsListDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.totalCount = data["totalCount"];
            if (data["items"] && data["items"].constructor === Array) {
                this.items = [];
                for (let item of data["items"])
                    this.items.push(AccountListDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfAccountsListDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfAccountsListDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (this.items && this.items.constructor === Array) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IPagedResultDtoOfAccountsListDto {
    totalCount?: number | undefined;
    items?: AccountListDto[] | undefined;
}

export class AccountGroupDto implements IAccountGroupDto {
    id?: number | undefined;
    /** 账户组名称 */
    displayName?: string | undefined;
    /** 是否是默认组 */
    isDefault?: boolean | undefined;
    /** 是否静态（系统生成），不可删除 */
    isStatic?: boolean | undefined;

    constructor(data?: IAccountGroupDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.displayName = data["displayName"];
            this.isDefault = data["isDefault"];
            this.isStatic = data["isStatic"];
        }
    }

    static fromJS(data: any): AccountGroupDto {
        data = typeof data === 'object' ? data : {};
        let result = new AccountGroupDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["displayName"] = this.displayName;
        data["isDefault"] = this.isDefault;
        data["isStatic"] = this.isStatic;
        return data; 
    }
}

export interface IAccountGroupDto {
    id?: number | undefined;
    /** 账户组名称 */
    displayName?: string | undefined;
    /** 是否是默认组 */
    isDefault?: boolean | undefined;
    /** 是否静态（系统生成），不可删除 */
    isStatic?: boolean | undefined;
}

export class ListResultDtoOfAccountGroupDto implements IListResultDtoOfAccountGroupDto {
    items?: AccountGroupDto[] | undefined;

    constructor(data?: IListResultDtoOfAccountGroupDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            if (data["items"] && data["items"].constructor === Array) {
                this.items = [];
                for (let item of data["items"])
                    this.items.push(AccountGroupDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ListResultDtoOfAccountGroupDto {
        data = typeof data === 'object' ? data : {};
        let result = new ListResultDtoOfAccountGroupDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (this.items && this.items.constructor === Array) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IListResultDtoOfAccountGroupDto {
    items?: AccountGroupDto[] | undefined;
}

export class CreateAccountGroupDto implements ICreateAccountGroupDto {
    /** 账户组名称 */
    displayName?: string | undefined;
    /** 是否是默认组 */
    isDefault?: boolean | undefined;

    constructor(data?: ICreateAccountGroupDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.displayName = data["displayName"];
            this.isDefault = data["isDefault"];
        }
    }

    static fromJS(data: any): CreateAccountGroupDto {
        data = typeof data === 'object' ? data : {};
        let result = new CreateAccountGroupDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["displayName"] = this.displayName;
        data["isDefault"] = this.isDefault;
        return data; 
    }
}

export interface ICreateAccountGroupDto {
    /** 账户组名称 */
    displayName?: string | undefined;
    /** 是否是默认组 */
    isDefault?: boolean | undefined;
}

export class UpdateAccountGroupDto implements IUpdateAccountGroupDto {
    /** 账户组名称 */
    displayName?: string | undefined;
    /** 是否是默认组 */
    isDefault?: boolean | undefined;

    constructor(data?: IUpdateAccountGroupDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.displayName = data["displayName"];
            this.isDefault = data["isDefault"];
        }
    }

    static fromJS(data: any): UpdateAccountGroupDto {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateAccountGroupDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["displayName"] = this.displayName;
        data["isDefault"] = this.isDefault;
        return data; 
    }
}

export interface IUpdateAccountGroupDto {
    /** 账户组名称 */
    displayName?: string | undefined;
    /** 是否是默认组 */
    isDefault?: boolean | undefined;
}

/** 使用中/未使用/逾期 */
export enum AppStatus {
    InUse = "InUse", 
    NotInUse = "NotInUse", 
    Overdue = "Overdue", 
}

/** 标准版/定制版 */
export enum AppEditionType {
    Standard = "Standard", 
    Customize = "Customize", 
}

export class AuthorizeTenantDto implements IAuthorizeTenantDto {
    tenantId?: number | undefined;
    appId?: number | undefined;
    /** 基础功能 */
    basic?: boolean | undefined;
    /** 基础功能预期时间 */
    basicExpiryTime?: number | undefined;
    /** 付费功能 */
    pay?: boolean | undefined;
    /** 付费功能预期时间 */
    payExpiryTime?: number | undefined;

    constructor(data?: IAuthorizeTenantDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.tenantId = data["tenantId"];
            this.appId = data["appId"];
            this.basic = data["basic"];
            this.basicExpiryTime = data["basicExpiryTime"];
            this.pay = data["pay"];
            this.payExpiryTime = data["payExpiryTime"];
        }
    }

    static fromJS(data: any): AuthorizeTenantDto {
        data = typeof data === 'object' ? data : {};
        let result = new AuthorizeTenantDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["tenantId"] = this.tenantId;
        data["appId"] = this.appId;
        data["basic"] = this.basic;
        data["basicExpiryTime"] = this.basicExpiryTime;
        data["pay"] = this.pay;
        data["payExpiryTime"] = this.payExpiryTime;
        return data; 
    }
}

export interface IAuthorizeTenantDto {
    tenantId?: number | undefined;
    appId?: number | undefined;
    /** 基础功能 */
    basic?: boolean | undefined;
    /** 基础功能预期时间 */
    basicExpiryTime?: number | undefined;
    /** 付费功能 */
    pay?: boolean | undefined;
    /** 付费功能预期时间 */
    payExpiryTime?: number | undefined;
}

export class TenantAppsDto implements ITenantAppsDto {
    tenant?: TenantDto | undefined;
    apps?: AppDto[] | undefined;

    constructor(data?: ITenantAppsDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.tenant = data["tenant"] ? TenantDto.fromJS(data["tenant"]) : <any>undefined;
            if (data["apps"] && data["apps"].constructor === Array) {
                this.apps = [];
                for (let item of data["apps"])
                    this.apps.push(AppDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): TenantAppsDto {
        data = typeof data === 'object' ? data : {};
        let result = new TenantAppsDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["tenant"] = this.tenant ? this.tenant.toJSON() : <any>undefined;
        if (this.apps && this.apps.constructor === Array) {
            data["apps"] = [];
            for (let item of this.apps)
                data["apps"].push(item.toJSON());
        }
        return data; 
    }
}

export interface ITenantAppsDto {
    tenant?: TenantDto | undefined;
    apps?: AppDto[] | undefined;
}

export class AppDto implements IAppDto {
    id?: number | undefined;
    displayName?: string | undefined;
    appKey?: string | undefined;
    appEditionType?: AppEditionType | undefined;
    status?: AppStatus | undefined;
    /** 基础功能 */
    basic?: boolean | undefined;
    /** 基础功能预期时间 */
    basicExpiryTime?: number | undefined;
    /** 付费功能 */
    pay?: boolean | undefined;
    /** 付费功能预期时间 */
    payExpiryTime?: number | undefined;

    constructor(data?: IAppDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.displayName = data["displayName"];
            this.appKey = data["appKey"];
            this.appEditionType = data["appEditionType"];
            this.status = data["status"];
            this.basic = data["basic"];
            this.basicExpiryTime = data["basicExpiryTime"];
            this.pay = data["pay"];
            this.payExpiryTime = data["payExpiryTime"];
        }
    }

    static fromJS(data: any): AppDto {
        data = typeof data === 'object' ? data : {};
        let result = new AppDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["displayName"] = this.displayName;
        data["appKey"] = this.appKey;
        data["appEditionType"] = this.appEditionType;
        data["status"] = this.status;
        data["basic"] = this.basic;
        data["basicExpiryTime"] = this.basicExpiryTime;
        data["pay"] = this.pay;
        data["payExpiryTime"] = this.payExpiryTime;
        return data; 
    }
}

export interface IAppDto {
    id?: number | undefined;
    displayName?: string | undefined;
    appKey?: string | undefined;
    appEditionType?: AppEditionType | undefined;
    status?: AppStatus | undefined;
    /** 基础功能 */
    basic?: boolean | undefined;
    /** 基础功能预期时间 */
    basicExpiryTime?: number | undefined;
    /** 付费功能 */
    pay?: boolean | undefined;
    /** 付费功能预期时间 */
    payExpiryTime?: number | undefined;
}

export class ListResultDtoOfAppDto implements IListResultDtoOfAppDto {
    items?: AppDto[] | undefined;

    constructor(data?: IListResultDtoOfAppDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            if (data["items"] && data["items"].constructor === Array) {
                this.items = [];
                for (let item of data["items"])
                    this.items.push(AppDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ListResultDtoOfAppDto {
        data = typeof data === 'object' ? data : {};
        let result = new ListResultDtoOfAppDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (this.items && this.items.constructor === Array) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IListResultDtoOfAppDto {
    items?: AppDto[] | undefined;
}

export class TenantDto implements ITenantDto {
    /** 租户key */
    id?: number | undefined;
    /** 租户编号 */
    code?: string | undefined;
    /** 租户名称 */
    displayName?: string | undefined;
    /** 租户过期时间 */
    expiryTime?: number | undefined;
    /** 是否激活租户 */
    isActive?: boolean | undefined;

    constructor(data?: ITenantDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.code = data["code"];
            this.displayName = data["displayName"];
            this.expiryTime = data["expiryTime"];
            this.isActive = data["isActive"];
        }
    }

    static fromJS(data: any): TenantDto {
        data = typeof data === 'object' ? data : {};
        let result = new TenantDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["code"] = this.code;
        data["displayName"] = this.displayName;
        data["expiryTime"] = this.expiryTime;
        data["isActive"] = this.isActive;
        return data; 
    }
}

export interface ITenantDto {
    /** 租户key */
    id?: number | undefined;
    /** 租户编号 */
    code?: string | undefined;
    /** 租户名称 */
    displayName?: string | undefined;
    /** 租户过期时间 */
    expiryTime?: number | undefined;
    /** 是否激活租户 */
    isActive?: boolean | undefined;
}

export class CreateTenantDto implements ICreateTenantDto {
    /** 租户编号 */
    code!: string;
    /** 租户名称 */
    displayName!: string;
    /** 租户描述 */
    desc?: string | undefined;
    /** 租户管理员邮箱 */
    adminEmail!: string;
    adminPassword!: string;
    /** 下次登录时密码重置 */
    shouldChangePasswordOnNextLogin?: boolean | undefined;
    /** 是否激活租户 */
    isActive?: boolean | undefined;
    /** 租户过期时间 */
    expiryTime?: number | undefined;

    constructor(data?: ICreateTenantDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.code = data["code"];
            this.displayName = data["displayName"];
            this.desc = data["desc"];
            this.adminEmail = data["adminEmail"];
            this.adminPassword = data["adminPassword"];
            this.shouldChangePasswordOnNextLogin = data["shouldChangePasswordOnNextLogin"];
            this.isActive = data["isActive"];
            this.expiryTime = data["expiryTime"];
        }
    }

    static fromJS(data: any): CreateTenantDto {
        data = typeof data === 'object' ? data : {};
        let result = new CreateTenantDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["code"] = this.code;
        data["displayName"] = this.displayName;
        data["desc"] = this.desc;
        data["adminEmail"] = this.adminEmail;
        data["adminPassword"] = this.adminPassword;
        data["shouldChangePasswordOnNextLogin"] = this.shouldChangePasswordOnNextLogin;
        data["isActive"] = this.isActive;
        data["expiryTime"] = this.expiryTime;
        return data; 
    }
}

export interface ICreateTenantDto {
    /** 租户编号 */
    code: string;
    /** 租户名称 */
    displayName: string;
    /** 租户描述 */
    desc?: string | undefined;
    /** 租户管理员邮箱 */
    adminEmail: string;
    adminPassword: string;
    /** 下次登录时密码重置 */
    shouldChangePasswordOnNextLogin?: boolean | undefined;
    /** 是否激活租户 */
    isActive?: boolean | undefined;
    /** 租户过期时间 */
    expiryTime?: number | undefined;
}

export class UpdateTenantDto implements IUpdateTenantDto {
    /** 租户名称 */
    displayName?: string | undefined;
    /** 租户描述 */
    desc?: string | undefined;
    /** 是否激活租户 */
    isActive!: boolean;
    /** 租户过期时间 */
    expiryTime?: number | undefined;

    constructor(data?: IUpdateTenantDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.displayName = data["displayName"];
            this.desc = data["desc"];
            this.isActive = data["isActive"];
            this.expiryTime = data["expiryTime"];
        }
    }

    static fromJS(data: any): UpdateTenantDto {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateTenantDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["displayName"] = this.displayName;
        data["desc"] = this.desc;
        data["isActive"] = this.isActive;
        data["expiryTime"] = this.expiryTime;
        return data; 
    }
}

export interface IUpdateTenantDto {
    /** 租户名称 */
    displayName?: string | undefined;
    /** 租户描述 */
    desc?: string | undefined;
    /** 是否激活租户 */
    isActive: boolean;
    /** 租户过期时间 */
    expiryTime?: number | undefined;
}

export class PagedResultDtoOfTenantListDto implements IPagedResultDtoOfTenantListDto {
    totalCount?: number | undefined;
    items?: TenantListDto[] | undefined;

    constructor(data?: IPagedResultDtoOfTenantListDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.totalCount = data["totalCount"];
            if (data["items"] && data["items"].constructor === Array) {
                this.items = [];
                for (let item of data["items"])
                    this.items.push(TenantListDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfTenantListDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfTenantListDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (this.items && this.items.constructor === Array) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IPagedResultDtoOfTenantListDto {
    totalCount?: number | undefined;
    items?: TenantListDto[] | undefined;
}

export class TenantListDto implements ITenantListDto {
    id?: number | undefined;
    code?: string | undefined;
    name?: string | undefined;
    isActive?: boolean | undefined;
    /** 创建时间 */
    createTime?: number | undefined;
    /** 过期时间 */
    expiryTime?: number | undefined;

    constructor(data?: ITenantListDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.code = data["code"];
            this.name = data["name"];
            this.isActive = data["isActive"];
            this.createTime = data["createTime"];
            this.expiryTime = data["expiryTime"];
        }
    }

    static fromJS(data: any): TenantListDto {
        data = typeof data === 'object' ? data : {};
        let result = new TenantListDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["code"] = this.code;
        data["name"] = this.name;
        data["isActive"] = this.isActive;
        data["createTime"] = this.createTime;
        data["expiryTime"] = this.expiryTime;
        return data; 
    }
}

export interface ITenantListDto {
    id?: number | undefined;
    code?: string | undefined;
    name?: string | undefined;
    isActive?: boolean | undefined;
    /** 创建时间 */
    createTime?: number | undefined;
    /** 过期时间 */
    expiryTime?: number | undefined;
}

export class FilterTenantsDto implements IFilterTenantsDto {
    filter?: string | undefined;
    tenantCode?: string | undefined;
    tenantName?: string | undefined;
    appId?: number | undefined;
    createDateStart?: number | undefined;
    createDateEnd?: number | undefined;
    pageIndex?: number | undefined;
    pageSize?: number | undefined;

    constructor(data?: IFilterTenantsDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.filter = data["filter"];
            this.tenantCode = data["tenantCode"];
            this.tenantName = data["tenantName"];
            this.appId = data["appId"];
            this.createDateStart = data["createDateStart"];
            this.createDateEnd = data["createDateEnd"];
            this.pageIndex = data["pageIndex"];
            this.pageSize = data["pageSize"];
        }
    }

    static fromJS(data: any): FilterTenantsDto {
        data = typeof data === 'object' ? data : {};
        let result = new FilterTenantsDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["filter"] = this.filter;
        data["tenantCode"] = this.tenantCode;
        data["tenantName"] = this.tenantName;
        data["appId"] = this.appId;
        data["createDateStart"] = this.createDateStart;
        data["createDateEnd"] = this.createDateEnd;
        data["pageIndex"] = this.pageIndex;
        data["pageSize"] = this.pageSize;
        return data; 
    }
}

export interface IFilterTenantsDto {
    filter?: string | undefined;
    tenantCode?: string | undefined;
    tenantName?: string | undefined;
    appId?: number | undefined;
    createDateStart?: number | undefined;
    createDateEnd?: number | undefined;
    pageIndex?: number | undefined;
    pageSize?: number | undefined;
}

export class AuthenticateResultModel implements IAuthenticateResultModel {
    /** 授权Token */
    accessToken?: string | undefined;
    /** 有效时长 */
    expireInSeconds?: number | undefined;
    /** 是否需要重置密码 */
    shouldResetPassword?: boolean | undefined;
    /** 如果需要重置密码，生成ResetCode后返回前端 */
    passwordResetCode?: string | undefined;
    userId?: number | undefined;
    returnUrl?: string | undefined;

    constructor(data?: IAuthenticateResultModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.accessToken = data["accessToken"];
            this.expireInSeconds = data["expireInSeconds"];
            this.shouldResetPassword = data["shouldResetPassword"];
            this.passwordResetCode = data["passwordResetCode"];
            this.userId = data["userId"];
            this.returnUrl = data["returnUrl"];
        }
    }

    static fromJS(data: any): AuthenticateResultModel {
        data = typeof data === 'object' ? data : {};
        let result = new AuthenticateResultModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["accessToken"] = this.accessToken;
        data["expireInSeconds"] = this.expireInSeconds;
        data["shouldResetPassword"] = this.shouldResetPassword;
        data["passwordResetCode"] = this.passwordResetCode;
        data["userId"] = this.userId;
        data["returnUrl"] = this.returnUrl;
        return data; 
    }
}

export interface IAuthenticateResultModel {
    /** 授权Token */
    accessToken?: string | undefined;
    /** 有效时长 */
    expireInSeconds?: number | undefined;
    /** 是否需要重置密码 */
    shouldResetPassword?: boolean | undefined;
    /** 如果需要重置密码，生成ResetCode后返回前端 */
    passwordResetCode?: string | undefined;
    userId?: number | undefined;
    returnUrl?: string | undefined;
}

export class AuthenticateModel implements IAuthenticateModel {
    /** 用户名 */
    tenantCode!:string;
    userName!: string;
    password!: string;
    rememberClient?: boolean | undefined;
    /** 未登录时访问的页面，登录后需要重定向 */
    returnUrl?: string | undefined;

    constructor(data?: IAuthenticateModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.userName = data["userName"];
            this.password = data["password"];
            this.tenantCode = data["tenantCode"];
            this.rememberClient = data["rememberClient"];
            this.returnUrl = data["returnUrl"];
        }
    }

    static fromJS(data: any): AuthenticateModel {
        data = typeof data === 'object' ? data : {};
        let result = new AuthenticateModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["userName"] = this.userName;
        data["password"] = this.password;
        data["tenantCode"] = this.tenantCode;
        data["rememberClient"] = this.rememberClient;
        data["returnUrl"] = this.returnUrl;
        return data; 
    }
}

export interface IAuthenticateModel {
    /** 用户名 */
    userName: string;
    password: string;
    tenantCode:string;
    rememberClient?: boolean | undefined;
    /** 未登录时访问的页面，登录后需要重定向 */
    returnUrl?: string | undefined;
}

export interface FileParameter {
    data: any;
    fileName: string;
}

export class SwaggerException extends Error {
    message: string;
    status: number; 
    response: string; 
    headers: { [key: string]: any; };
    result: any; 

    constructor(message: string, status: number, response: string, headers: { [key: string]: any; }, result: any) {
        super();

        this.message = message;
        this.status = status;
        this.response = response;
        this.headers = headers;
        this.result = result;
    }

    protected isSwaggerException = true;

    static isSwaggerException(obj: any): obj is SwaggerException {
        return obj.isSwaggerException === true;
    }
}

function throwException(message: string, status: number, response: string, headers: { [key: string]: any; }, result?: any): Observable<any> {
    if(result !== null && result !== undefined)
        return _observableThrow(result);
    else
        return _observableThrow(new SwaggerException(message, status, response, headers, null));
}

function blobToText(blob: any): Observable<string> {
    return new Observable<string>((observer: any) => {
        if (!blob) {
            observer.next("");
            observer.complete();
        } else {
            let reader = new FileReader(); 
            reader.onload = event => { 
                observer.next((<any>event.target).result);
                observer.complete();
            };
            reader.readAsText(blob); 
        }
    });
}

// additional code need to integrate into service proxies
// code here will be add in the end of service proxies file
// ----------------------