/* tslint:disable */
//----------------------
// <auto-generated>
//     Generated using the NSwag toolchain v12.0.4.0 (NJsonSchema v9.12.7.0 (Newtonsoft.Json v11.0.0.0)) (http://NSwag.org)
// </auto-generated>
//----------------------
// ReSharper disable InconsistentNaming

import { mergeMap as _observableMergeMap, catchError as _observableCatch } from 'rxjs/operators';
import { Observable, throwError as _observableThrow, of as _observableOf } from 'rxjs';
import { Injectable, Inject, Optional, InjectionToken } from '@angular/core';
import { HttpClient, HttpHeaders, HttpResponse, HttpResponseBase } from '@angular/common/http';

export const API_BASE_URL = new InjectionToken<string>('API_BASE_URL');

@Injectable()
export class IotServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "http://192.168.1.198:8001/api-v1";
    }

    /**
     * 统计平台上IoT的信息
     * @return Success
     */
    summary(): Observable<IoTSummaryDto> {
        let url_ = this.baseUrl + "/iot/summary";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSummary(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSummary(<any>response_);
                } catch (e) {
                    return <Observable<IoTSummaryDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<IoTSummaryDto>><any>_observableThrow(response_);
        }));
    }

    protected processSummary(response: HttpResponseBase): Observable<IoTSummaryDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? IoTSummaryDto.fromJS(resultData200) : new IoTSummaryDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<IoTSummaryDto>(<any>null);
    }

    /**
     * 统计平台上IoT的分布
     * @return Success
     */
    map(): Observable<IoTMapDto> {
        let url_ = this.baseUrl + "/iot/map";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processMap(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processMap(<any>response_);
                } catch (e) {
                    return <Observable<IoTMapDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<IoTMapDto>><any>_observableThrow(response_);
        }));
    }

    protected processMap(response: HttpResponseBase): Observable<IoTMapDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? IoTMapDto.fromJS(resultData200) : new IoTMapDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<IoTMapDto>(<any>null);
    }
}

@Injectable()
export class PassportServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "http://192.168.1.198:8001/api-v1";
    }

    /**
     * 验证用户合法
     * @param authenticateModel (optional) 
     * @return Success
     */
    authenticate(authenticateModel: AuthenticateModel | null | undefined): Observable<AuthenticateResultModel> {
        let url_ = this.baseUrl + "/passport/authenticate";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(authenticateModel);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAuthenticate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAuthenticate(<any>response_);
                } catch (e) {
                    return <Observable<AuthenticateResultModel>><any>_observableThrow(e);
                }
            } else
                return <Observable<AuthenticateResultModel>><any>_observableThrow(response_);
        }));
    }

    protected processAuthenticate(response: HttpResponseBase): Observable<AuthenticateResultModel> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? AuthenticateResultModel.fromJS(resultData200) : new AuthenticateResultModel();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<AuthenticateResultModel>(<any>null);
    }
}

@Injectable()
export class AppServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "http://192.168.1.198:8001/api-v1";
    }

    /**
     * 列出所有App
     * @param pageSerchDto (optional) 按照分页条件过滤APP
     * @return Success
     */
    listAll(pageSerchDto: PageSearchDto | null | undefined): Observable<ListResultDtoOfAppListDto> {
        let url_ = this.baseUrl + "/app/all";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(pageSerchDto);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json"
            })
        };
        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processListAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processListAll(<any>response_);
                } catch (e) {
                    return <Observable<ListResultDtoOfAppListDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<ListResultDtoOfAppListDto>><any>_observableThrow(response_);
        }));
    }

    protected processListAll(response: HttpResponseBase): Observable<ListResultDtoOfAppListDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? ListResultDtoOfAppListDto.fromJS(resultData200) : new ListResultDtoOfAppListDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ListResultDtoOfAppListDto>(<any>null);
    }

    /**
     * 列出所有App
     * @return Success
     */
    listAllBrief(): Observable<ListResultDtoOfNameValueDto> {
        let url_ = this.baseUrl + "/app/all-brief";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processListAllBrief(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processListAllBrief(<any>response_);
                } catch (e) {
                    return <Observable<ListResultDtoOfNameValueDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<ListResultDtoOfNameValueDto>><any>_observableThrow(response_);
        }));
    }

    protected processListAllBrief(response: HttpResponseBase): Observable<ListResultDtoOfNameValueDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? ListResultDtoOfNameValueDto.fromJS(resultData200) : new ListResultDtoOfNameValueDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ListResultDtoOfNameValueDto>(<any>null);
    }

    /**
     * 列出特定租户下的所有App
     * @param tenantId 需要获得App的租户Id
     * @return Success
     */
    findByTenant(tenantId: number): Observable<TenantAppsDto> {
        let url_ = this.baseUrl + "/app/find-by-tenant/{tenantId}";
        if (tenantId === undefined || tenantId === null)
            throw new Error("The parameter 'tenantId' must be defined.");
        url_ = url_.replace("{tenantId}", encodeURIComponent("" + tenantId)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processFindByTenant(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processFindByTenant(<any>response_);
                } catch (e) {
                    return <Observable<TenantAppsDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<TenantAppsDto>><any>_observableThrow(response_);
        }));
    }

    protected processFindByTenant(response: HttpResponseBase): Observable<TenantAppsDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? TenantAppsDto.fromJS(resultData200) : new TenantAppsDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<TenantAppsDto>(<any>null);
    }

    /**
     * 授权租户App权限
     * @param createTenantDto (optional) 
     * @return OK
     */
    addAuthorize(createTenantDto: AuthorizeTenantDto | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/app/authorize";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(createTenantDto);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAddAuthorize(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAddAuthorize(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processAddAuthorize(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * 更新租户App权限
     * @param updateTenantDto (optional) 
     * @return OK
     */
    updateAuthorize(updateTenantDto: AuthorizeTenantDto | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/app/authorize";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(updateTenantDto);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateAuthorize(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateAuthorize(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processUpdateAuthorize(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * 操作App上下架
     * @param appId app id
     * @return Success
     */
    setStage(appId: number, stage: string): Observable<void> {
        let url_ = this.baseUrl + "/app/{appId}/set-stage/{stage}";
        if (appId === undefined || appId === null)
            throw new Error("The parameter 'appId' must be defined.");
        url_ = url_.replace("{appId}", encodeURIComponent("" + appId)); 
        if (stage === undefined || stage === null)
            throw new Error("The parameter 'stage' must be defined.");
        url_ = url_.replace("{stage}", encodeURIComponent("" + stage)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSetStage(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSetStage(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processSetStage(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * 统计平台上App的信息
     * @return Success
     */
    summary(): Observable<AppSummaryDto> {
        let url_ = this.baseUrl + "/app/summary";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSummary(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSummary(<any>response_);
                } catch (e) {
                    return <Observable<AppSummaryDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<AppSummaryDto>><any>_observableThrow(response_);
        }));
    }

    protected processSummary(response: HttpResponseBase): Observable<AppSummaryDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? AppSummaryDto.fromJS(resultData200) : new AppSummaryDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<AppSummaryDto>(<any>null);
    }
}

@Injectable()
export class TenantServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "http://192.168.1.198:8001/api-v1";
    }

    /**
     * 租户查询
     * @param filterTenants (optional) 按照查询条件过滤租户
     * @return Success
     */
    list(filterTenants: FilterTenantsDto | null | undefined): Observable<PagedResultDtoOfTenantListDto> {
        let url_ = this.baseUrl + "/tenant/searches";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(filterTenants);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processList(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processList(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfTenantListDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfTenantListDto>><any>_observableThrow(response_);
        }));
    }

    protected processList(response: HttpResponseBase): Observable<PagedResultDtoOfTenantListDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? PagedResultDtoOfTenantListDto.fromJS(resultData200) : new PagedResultDtoOfTenantListDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfTenantListDto>(<any>null);
    }

    /**
     * 租户开立
     * @param createTenantDto (optional) 
     * @return Success
     */
    add(createTenantDto: CreateTenantDto | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/tenant";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(createTenantDto);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAdd(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAdd(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processAdd(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * 根据Id获取租户
     * @param tenantId 租户Id
     * @return Success
     */
    get(tenantId: number): Observable<TenantDto> {
        let url_ = this.baseUrl + "/tenant/{tenantId}";
        if (tenantId === undefined || tenantId === null)
            throw new Error("The parameter 'tenantId' must be defined.");
        url_ = url_.replace("{tenantId}", encodeURIComponent("" + tenantId)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGet(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGet(<any>response_);
                } catch (e) {
                    return <Observable<TenantDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<TenantDto>><any>_observableThrow(response_);
        }));
    }

    protected processGet(response: HttpResponseBase): Observable<TenantDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? TenantDto.fromJS(resultData200) : new TenantDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<TenantDto>(<any>null);
    }

    /**
     * 更新租户
     * @param tenantId 租户Id
     * @param updateTenantDto (optional) 
     * @return Success
     */
    update(tenantId: number, updateTenantDto: UpdateTenantDto | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/tenant/{tenantId}";
        if (tenantId === undefined || tenantId === null)
            throw new Error("The parameter 'tenantId' must be defined.");
        url_ = url_.replace("{tenantId}", encodeURIComponent("" + tenantId)); 
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(updateTenantDto);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdate(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processUpdate(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * 统计平台上租户的信息
     * @return Success
     */
    summary(): Observable<TenantSummaryDto> {
        let url_ = this.baseUrl + "/tenant/summary";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSummary(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSummary(<any>response_);
                } catch (e) {
                    return <Observable<TenantSummaryDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<TenantSummaryDto>><any>_observableThrow(response_);
        }));
    }

    protected processSummary(response: HttpResponseBase): Observable<TenantSummaryDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? TenantSummaryDto.fromJS(resultData200) : new TenantSummaryDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<TenantSummaryDto>(<any>null);
    }
}

@Injectable()
export class AccountServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "http://192.168.1.198:8001/api-v1";
    }

    /**
     * 统计平台上用户的信息
     * @return Success
     */
    summary(): Observable<AccountSummaryDto> {
        let url_ = this.baseUrl + "/account/summary";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSummary(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSummary(<any>response_);
                } catch (e) {
                    return <Observable<AccountSummaryDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<AccountSummaryDto>><any>_observableThrow(response_);
        }));
    }

    protected processSummary(response: HttpResponseBase): Observable<AccountSummaryDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? AccountSummaryDto.fromJS(resultData200) : new AccountSummaryDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<AccountSummaryDto>(<any>null);
    }

    /**
     * 统计平台上用户的分布
     * @return Success
     */
    map(): Observable<AccountMapDto> {
        let url_ = this.baseUrl + "/account/map";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processMap(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processMap(<any>response_);
                } catch (e) {
                    return <Observable<AccountMapDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<AccountMapDto>><any>_observableThrow(response_);
        }));
    }

    protected processMap(response: HttpResponseBase): Observable<AccountMapDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? AccountMapDto.fromJS(resultData200) : new AccountMapDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<AccountMapDto>(<any>null);
    }

    /**
     * 账户查询
     * @param filterAccounts (optional) 按照查询条件过滤租户
     * @return Success
     */
    list(filterAccounts: FilterAccountsDto | null | undefined): Observable<PagedResultDtoOfAccountsListDto> {
        let url_ = this.baseUrl + "/account/searches";
        url_ = url_.replace(/[?&]$/, "");
        filterAccounts.toJSON
        const content_ = filterAccounts.toJSON();

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processList(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processList(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfAccountsListDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfAccountsListDto>><any>_observableThrow(response_);
        }));
    }

    protected processList(response: HttpResponseBase): Observable<PagedResultDtoOfAccountsListDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? PagedResultDtoOfAccountsListDto.fromJS(resultData200) : new PagedResultDtoOfAccountsListDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfAccountsListDto>(<any>null);
    }

    /**
     * 建立账户
     * @param createAccount (optional) 新建账户
     * @return Success
     */
    add(createAccount: CreateAccountDto | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/account";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(createAccount);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAdd(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAdd(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processAdd(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * 更新账户
     * @param accountId 账户Id
     * @param updateAccount (optional) 更新账户
     * @return Succes
     */
    update(accountId: number, updateAccount: UpdateAccountDto | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/account";
        if (accountId === undefined || accountId === null)
            throw new Error("The parameter 'accountId' must be defined.");
        url_ = url_.replace("{accountId}", encodeURIComponent("" + accountId)); 
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(updateAccount);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdate(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processUpdate(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * 查询特定账户
     * @param accountId 账户Id
     * @return Succes
     */
    get(accountId: number): Observable<AccountDto> {
        let url_ = this.baseUrl + "/account/{accountId}";
        if (accountId === undefined || accountId === null)
            throw new Error("The parameter 'accountId' must be defined.");
        url_ = url_.replace("{accountId}", encodeURIComponent("" + accountId)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGet(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGet(<any>response_);
                } catch (e) {
                    return <Observable<AccountDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<AccountDto>><any>_observableThrow(response_);
        }));
    }

    protected processGet(response: HttpResponseBase): Observable<AccountDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? AccountDto.fromJS(resultData200) : new AccountDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<AccountDto>(<any>null);
    }

    /**
     * 删除账户
     * @param accountId 账户Id
     * @return Succes
     */
    delete(accountId: number): Observable<void> {
        let url_ = this.baseUrl + "/account/{accountId}";
        if (accountId === undefined || accountId === null)
            throw new Error("The parameter 'accountId' must be defined.");
        url_ = url_.replace("{accountId}", encodeURIComponent("" + accountId)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * 上传头像
     * @param accountId ID of Account to update
     * @param additionalMetadata (optional) Additional data to pass to server
     * @param file (optional) file to upload
     * @return successful operation
     */
    uploadImage(accountId: number, additionalMetadata: string | null | undefined, file: FileParameter | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/account/{accountId}/upload-image";
        if (accountId === undefined || accountId === null)
            throw new Error("The parameter 'accountId' must be defined.");
        url_ = url_.replace("{accountId}", encodeURIComponent("" + accountId)); 
        url_ = url_.replace(/[?&]$/, "");

        const content_ = new FormData();
        if (additionalMetadata !== null && additionalMetadata !== undefined)
            content_.append("additionalMetadata", additionalMetadata.toString());
        if (file !== null && file !== undefined)
            content_.append("file", file.data, file.fileName ? file.fileName : "file");

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUploadImage(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUploadImage(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processUploadImage(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }
}

@Injectable()
export class AccountGroupServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "http://192.168.1.198:8001/api-v1";
    }

    /**
     * 账户组查询
     * @return Success
     */
    list(): Observable<ListResultDtoOfAccountGroupDto> {
        let url_ = this.baseUrl + "/account-group/all";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processList(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processList(<any>response_);
                } catch (e) {
                    return <Observable<ListResultDtoOfAccountGroupDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<ListResultDtoOfAccountGroupDto>><any>_observableThrow(response_);
        }));
    }

    protected processList(response: HttpResponseBase): Observable<ListResultDtoOfAccountGroupDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? ListResultDtoOfAccountGroupDto.fromJS(resultData200) : new ListResultDtoOfAccountGroupDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ListResultDtoOfAccountGroupDto>(<any>null);
    }

    /**
     * 新建账户组
     * @param createAccountGroup (optional) 
     * @return Success
     */
    add(createAccountGroup: CreateAccountGroupDto | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/account-group";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(createAccountGroup);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAdd(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAdd(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processAdd(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * 更新账户组
     * @param accountGroupId 账户组Id
     * @param updateAccountGroup (optional) 更新账户组
     * @return Succes
     */
    update(accountGroupId: number, updateAccountGroup: UpdateAccountGroupDto | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/account-group/{accountGroupId}";
        if (accountGroupId === undefined || accountGroupId === null)
            throw new Error("The parameter 'accountGroupId' must be defined.");
        url_ = url_.replace("{accountGroupId}", encodeURIComponent("" + accountGroupId)); 
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(updateAccountGroup);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdate(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processUpdate(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * 删除账户组
     * @param accountGroupId 账户组Id
     * @return Succes
     */
    delete(accountGroupId: number): Observable<void> {
        let url_ = this.baseUrl + "/account-group/{accountGroupId}";
        if (accountGroupId === undefined || accountGroupId === null)
            throw new Error("The parameter 'accountGroupId' must be defined.");
        url_ = url_.replace("{accountGroupId}", encodeURIComponent("" + accountGroupId)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }
}

@Injectable()
export class AuditLogServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "http://192.168.1.198:8001/api-v1";
    }

    /**
     * 审计日志查询
     * @param filterAuditLogs (optional) 按照查询条件过滤审计日志
     * @return Success
     */
    list(filterAuditLogs: FilterAuditLogsDto | null | undefined): Observable<PagedResultDtoOfAuditLogsListDto> {
        let url_ = this.baseUrl + "/audit-log/searches";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(filterAuditLogs);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processList(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processList(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfAuditLogsListDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfAuditLogsListDto>><any>_observableThrow(response_);
        }));
    }

    protected processList(response: HttpResponseBase): Observable<PagedResultDtoOfAuditLogsListDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? PagedResultDtoOfAuditLogsListDto.fromJS(resultData200) : new PagedResultDtoOfAuditLogsListDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfAuditLogsListDto>(<any>null);
    }
}

@Injectable()
export class PermissionServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "http://192.168.1.198:8001/api-v1";
    }

    /**
     * 列出所有权限
     * @return Success
     */
    listAll(): Observable<ListResultDtoOfPermissionDto> {
        let url_ = this.baseUrl + "/permission/all";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processListAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processListAll(<any>response_);
                } catch (e) {
                    return <Observable<ListResultDtoOfPermissionDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<ListResultDtoOfPermissionDto>><any>_observableThrow(response_);
        }));
    }

    protected processListAll(response: HttpResponseBase): Observable<ListResultDtoOfPermissionDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? ListResultDtoOfPermissionDto.fromJS(resultData200) : new ListResultDtoOfPermissionDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ListResultDtoOfPermissionDto>(<any>null);
    }

    /**
     * 列出用户组的所有权限
     * @param accountGroupId 账户组Id
     * @return Success
     */
    listByAccountGroupId(accountGroupId: number): Observable<ListResultDtoOfPermissionDto> {
        let url_ = this.baseUrl + "/permission/account-group/{accountGroupId}";
        if (accountGroupId === undefined || accountGroupId === null)
            throw new Error("The parameter 'accountGroupId' must be defined.");
        url_ = url_.replace("{accountGroupId}", encodeURIComponent("" + accountGroupId)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processListByAccountGroupId(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processListByAccountGroupId(<any>response_);
                } catch (e) {
                    return <Observable<ListResultDtoOfPermissionDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<ListResultDtoOfPermissionDto>><any>_observableThrow(response_);
        }));
    }

    protected processListByAccountGroupId(response: HttpResponseBase): Observable<ListResultDtoOfPermissionDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? ListResultDtoOfPermissionDto.fromJS(resultData200) : new ListResultDtoOfPermissionDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ListResultDtoOfPermissionDto>(<any>null);
    }

    /**
     * 更新用户组的所有权限
     * @param accountGroupId 账户组Id
     * @param updateAccountGroupPermission (optional) 更新账户组权限
     * @return Success
     */
    updateAccountGroupPermissions(accountGroupId: number, updateAccountGroupPermission: GrantedPermissionsDto | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/permission/account-group/{accountGroupId}";
        if (accountGroupId === undefined || accountGroupId === null)
            throw new Error("The parameter 'accountGroupId' must be defined.");
        url_ = url_.replace("{accountGroupId}", encodeURIComponent("" + accountGroupId)); 
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(updateAccountGroupPermission);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateAccountGroupPermissions(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateAccountGroupPermissions(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processUpdateAccountGroupPermissions(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * 列出用户的所有权限
     * @param accountId 账户Id
     * @return Success
     */
    listByAccountId(accountId: number): Observable<ListResultDtoOfPermissionDto> {
        let url_ = this.baseUrl + "/permission/account/{accountId}";
        if (accountId === undefined || accountId === null)
            throw new Error("The parameter 'accountId' must be defined.");
        url_ = url_.replace("{accountId}", encodeURIComponent("" + accountId)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processListByAccountId(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processListByAccountId(<any>response_);
                } catch (e) {
                    return <Observable<ListResultDtoOfPermissionDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<ListResultDtoOfPermissionDto>><any>_observableThrow(response_);
        }));
    }

    protected processListByAccountId(response: HttpResponseBase): Observable<ListResultDtoOfPermissionDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? ListResultDtoOfPermissionDto.fromJS(resultData200) : new ListResultDtoOfPermissionDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ListResultDtoOfPermissionDto>(<any>null);
    }

    /**
     * 更新用户的所有权限
     * @param accountId 账户Id
     * @param updateAccountPermission (optional) 更新账户权限
     * @return Success
     */
    updateAccountPermissions(accountId: number, updateAccountPermission: GrantedPermissionsDto | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/permission/account/{accountId}";
        if (accountId === undefined || accountId === null)
            throw new Error("The parameter 'accountId' must be defined.");
        url_ = url_.replace("{accountId}", encodeURIComponent("" + accountId)); 
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(updateAccountPermission);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateAccountPermissions(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateAccountPermissions(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processUpdateAccountPermissions(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }
}

@Injectable()
export class SettingsServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "http://192.168.1.198:8001/api-v1";
    }

    /**
     * 列出租户的所有设定
     * @return Success
     */
    listAll(): Observable<SettingsDto> {
        let url_ = this.baseUrl + "/settings/all";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processListAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processListAll(<any>response_);
                } catch (e) {
                    return <Observable<SettingsDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<SettingsDto>><any>_observableThrow(response_);
        }));
    }

    protected processListAll(response: HttpResponseBase): Observable<SettingsDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? SettingsDto.fromJS(resultData200) : new SettingsDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SettingsDto>(<any>null);
    }

    /**
     * 更新租户的所有设定
     * @param updateTenantAllSettings (optional) 更新账户组权限
     * @return Success
     */
    updateAll(updateTenantAllSettings: SettingsDto | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/settings/all";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(updateTenantAllSettings);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateAll(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processUpdateAll(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * 用户登录后，返回菜单、权限和设定数据
     * @return Success
     */
    startup(): Observable<StartupDto> {
        let url_ = this.baseUrl + "/settings/startup";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processStartup(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processStartup(<any>response_);
                } catch (e) {
                    return <Observable<StartupDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<StartupDto>><any>_observableThrow(response_);
        }));
    }

    protected processStartup(response: HttpResponseBase): Observable<StartupDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? StartupDto.fromJS(resultData200) : new StartupDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<StartupDto>(<any>null);
    }
}

export class MenuItemDto implements IMenuItemDto {
    text?: string | undefined;
    icon?: string | undefined;
    link?: string | undefined;
    children?: MenuItemDto[] | undefined;

    constructor(data?: IMenuItemDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.text = data["text"];
            this.icon = data["icon"];
            this.link = data["link"];
            if (data["children"] && data["children"].constructor === Array) {
                this.children = [];
                for (let item of data["children"])
                    this.children.push(MenuItemDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): MenuItemDto {
        data = typeof data === 'object' ? data : {};
        let result = new MenuItemDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["text"] = this.text;
        data["icon"] = this.icon;
        data["link"] = this.link;
        if (this.children && this.children.constructor === Array) {
            data["children"] = [];
            for (let item of this.children)
                data["children"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IMenuItemDto {
    text?: string | undefined;
    icon?: string | undefined;
    link?: string | undefined;
    children?: MenuItemDto[] | undefined;
}

export class StartupDto implements IStartupDto {
    grantedPermissions?: string[] | undefined;
    menus?: MenuItemDto[] | undefined;
    settings?: SettingsDto | undefined;

    constructor(data?: IStartupDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            if (data["grantedPermissions"] && data["grantedPermissions"].constructor === Array) {
                this.grantedPermissions = [];
                for (let item of data["grantedPermissions"])
                    this.grantedPermissions.push(item);
            }
            if (data["menus"] && data["menus"].constructor === Array) {
                this.menus = [];
                for (let item of data["menus"])
                    this.menus.push(MenuItemDto.fromJS(item));
            }
            this.settings = data["settings"] ? SettingsDto.fromJS(data["settings"]) : <any>undefined;
        }
    }

    static fromJS(data: any): StartupDto {
        data = typeof data === 'object' ? data : {};
        let result = new StartupDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (this.grantedPermissions && this.grantedPermissions.constructor === Array) {
            data["grantedPermissions"] = [];
            for (let item of this.grantedPermissions)
                data["grantedPermissions"].push(item);
        }
        if (this.menus && this.menus.constructor === Array) {
            data["menus"] = [];
            for (let item of this.menus)
                data["menus"].push(item.toJSON());
        }
        data["settings"] = this.settings ? this.settings.toJSON() : <any>undefined;
        return data; 
    }
}

export interface IStartupDto {
    grantedPermissions?: string[] | undefined;
    menus?: MenuItemDto[] | undefined;
    settings?: SettingsDto | undefined;
}

export class SettingsDto implements ISettingsDto {
    logo?: string | undefined;
    themeColor?: string | undefined;
    defalutMenuState?: string | undefined;

    constructor(data?: ISettingsDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.logo = data["logo"];
            this.themeColor = data["themeColor"];
            this.defalutMenuState = data["defalutMenuState"];
        }
    }

    static fromJS(data: any): SettingsDto {
        data = typeof data === 'object' ? data : {};
        let result = new SettingsDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["logo"] = this.logo;
        data["themeColor"] = this.themeColor;
        data["defalutMenuState"] = this.defalutMenuState;
        return data; 
    }
}

export interface ISettingsDto {
    logo?: string | undefined;
    themeColor?: string | undefined;
    defalutMenuState?: string | undefined;
}

export class GrantedPermissionsDto implements IGrantedPermissionsDto {
    ids?: number[] | undefined;

    constructor(data?: IGrantedPermissionsDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            if (data["ids"] && data["ids"].constructor === Array) {
                this.ids = [];
                for (let item of data["ids"])
                    this.ids.push(item);
            }
        }
    }

    static fromJS(data: any): GrantedPermissionsDto {
        data = typeof data === 'object' ? data : {};
        let result = new GrantedPermissionsDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (this.ids && this.ids.constructor === Array) {
            data["ids"] = [];
            for (let item of this.ids)
                data["ids"].push(item);
        }
        return data; 
    }
}

export interface IGrantedPermissionsDto {
    ids?: number[] | undefined;
}

export class PermissionDto implements IPermissionDto {
    id?: number | undefined;
    level?: number | undefined;
    parentId?: number | undefined;
    displayName?: string | undefined;
    desc?: string | undefined;

    constructor(data?: IPermissionDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.level = data["level"];
            this.parentId = data["parentId"];
            this.displayName = data["displayName"];
            this.desc = data["desc"];
        }
    }

    static fromJS(data: any): PermissionDto {
        data = typeof data === 'object' ? data : {};
        let result = new PermissionDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["level"] = this.level;
        data["parentId"] = this.parentId;
        data["displayName"] = this.displayName;
        data["desc"] = this.desc;
        return data; 
    }
}

export interface IPermissionDto {
    id?: number | undefined;
    level?: number | undefined;
    parentId?: number | undefined;
    displayName?: string | undefined;
    desc?: string | undefined;
}

export class ListResultDtoOfPermissionDto implements IListResultDtoOfPermissionDto {
    items?: PermissionDto[] | undefined;

    constructor(data?: IListResultDtoOfPermissionDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            if (data["items"] && data["items"].constructor === Array) {
                this.items = [];
                for (let item of data["items"])
                    this.items.push(PermissionDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ListResultDtoOfPermissionDto {
        data = typeof data === 'object' ? data : {};
        let result = new ListResultDtoOfPermissionDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (this.items && this.items.constructor === Array) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IListResultDtoOfPermissionDto {
    items?: PermissionDto[] | undefined;
}

export class FilterAuditLogsDto implements IFilterAuditLogsDto {
    /** 创建时间从 */
    createTimeFrom?: number | undefined;
    /** 创建时间到 */
    createTimeEnd?: number | undefined;
    timeOfDurationFrom?: number | undefined;
    timeOfDurationEnd?: number | undefined;
    status?: string | undefined;
    account?: string | undefined;
    pageIndex?: number | undefined;
    pageSize?: number | undefined;

    constructor(data?: IFilterAuditLogsDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.createTimeFrom = data["createTimeFrom"];
            this.createTimeEnd = data["createTimeEnd"];
            this.timeOfDurationFrom = data["timeOfDurationFrom"];
            this.timeOfDurationEnd = data["timeOfDurationEnd"];
            this.status = data["status"];
            this.account = data["account"];
            this.pageIndex = data["pageIndex"];
            this.pageSize = data["pageSize"];
        }
    }

    static fromJS(data: any): FilterAuditLogsDto {
        data = typeof data === 'object' ? data : {};
        let result = new FilterAuditLogsDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["createTimeFrom"] = this.createTimeFrom;
        data["createTimeEnd"] = this.createTimeEnd;
        data["timeOfDurationFrom"] = this.timeOfDurationFrom;
        data["timeOfDurationEnd"] = this.timeOfDurationEnd;
        data["status"] = this.status;
        data["account"] = this.account;
        data["pageIndex"] = this.pageIndex;
        data["pageSize"] = this.pageSize;
        return data; 
    }
}

export interface IFilterAuditLogsDto {
    /** 创建时间从 */
    createTimeFrom?: number | undefined;
    /** 创建时间到 */
    createTimeEnd?: number | undefined;
    timeOfDurationFrom?: number | undefined;
    timeOfDurationEnd?: number | undefined;
    status?: string | undefined;
    account?: string | undefined;
    pageIndex?: number | undefined;
    pageSize?: number | undefined;
}

export class AuditLogsListDto implements IAuditLogsListDto {
    id?: number | undefined;
    account?: string | undefined;
    app?: string | undefined;
    api?: string | undefined;
    status?: string | undefined;
    createTime?: number | undefined;
    timeOfDuration?: number | undefined;
    ip?: string | undefined;
    client?: string | undefined;

    constructor(data?: IAuditLogsListDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.account = data["account"];
            this.app = data["app"];
            this.api = data["api"];
            this.status = data["status"];
            this.createTime = data["createTime"];
            this.timeOfDuration = data["timeOfDuration"];
            this.ip = data["ip"];
            this.client = data["client"];
        }
    }

    static fromJS(data: any): AuditLogsListDto {
        data = typeof data === 'object' ? data : {};
        let result = new AuditLogsListDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["account"] = this.account;
        data["app"] = this.app;
        data["api"] = this.api;
        data["status"] = this.status;
        data["createTime"] = this.createTime;
        data["timeOfDuration"] = this.timeOfDuration;
        data["ip"] = this.ip;
        data["client"] = this.client;
        return data; 
    }
}

export interface IAuditLogsListDto {
    id?: number | undefined;
    account?: string | undefined;
    app?: string | undefined;
    api?: string | undefined;
    status?: string | undefined;
    createTime?: number | undefined;
    timeOfDuration?: number | undefined;
    ip?: string | undefined;
    client?: string | undefined;
}

export class PagedResultDtoOfAuditLogsListDto implements IPagedResultDtoOfAuditLogsListDto {
    totalCount?: number | undefined;
    items?: AuditLogsListDto[] | undefined;

    constructor(data?: IPagedResultDtoOfAuditLogsListDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.totalCount = data["totalCount"];
            if (data["items"] && data["items"].constructor === Array) {
                this.items = [];
                for (let item of data["items"])
                    this.items.push(AuditLogsListDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfAuditLogsListDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfAuditLogsListDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (this.items && this.items.constructor === Array) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IPagedResultDtoOfAuditLogsListDto {
    totalCount?: number | undefined;
    items?: AuditLogsListDto[] | undefined;
}

export class AccountDto implements IAccountDto {
    id?: number | undefined;
    /** 账户编号 */
    code?: string | undefined;
    /** 账户名称 */
    displayName?: string | undefined;
    /** 邮箱 */
    email?: string | undefined;
    /** 账户是否启用 */
    isActive?: boolean | undefined;
    /** 创建时间 */
    createTime?: number | undefined;
    /** 用户所在组 */
    ownGroupIds?: number[] | undefined;

    constructor(data?: IAccountDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.code = data["code"];
            this.displayName = data["displayName"];
            this.email = data["email"];
            this.isActive = data["isActive"];
            this.createTime = data["createTime"];
            if (data["ownGroupIds"] && data["ownGroupIds"].constructor === Array) {
                this.ownGroupIds = [];
                for (let item of data["ownGroupIds"])
                    this.ownGroupIds.push(item);
            }
        }
    }

    static fromJS(data: any): AccountDto {
        data = typeof data === 'object' ? data : {};
        let result = new AccountDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["code"] = this.code;
        data["displayName"] = this.displayName;
        data["email"] = this.email;
        data["isActive"] = this.isActive;
        data["createTime"] = this.createTime;
        if (this.ownGroupIds && this.ownGroupIds.constructor === Array) {
            data["ownGroupIds"] = [];
            for (let item of this.ownGroupIds)
                data["ownGroupIds"].push(item);
        }
        return data; 
    }
}

export interface IAccountDto {
    id?: number | undefined;
    /** 账户编号 */
    code?: string | undefined;
    /** 账户名称 */
    displayName?: string | undefined;
    /** 邮箱 */
    email?: string | undefined;
    /** 账户是否启用 */
    isActive?: boolean | undefined;
    /** 创建时间 */
    createTime?: number | undefined;
    /** 用户所在组 */
    ownGroupIds?: number[] | undefined;
}

export class AccountSummaryDto implements IAccountSummaryDto {
    /** 账户总数 */
    totalCount?: number | undefined;
    /** 启用的账户总数 */
    activeCount?: number | undefined;
    /** 停用的账户总数 */
    inactiveCount?: number | undefined;

    constructor(data?: IAccountSummaryDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.totalCount = data["totalCount"];
            this.activeCount = data["activeCount"];
            this.inactiveCount = data["inactiveCount"];
        }
    }

    static fromJS(data: any): AccountSummaryDto {
        data = typeof data === 'object' ? data : {};
        let result = new AccountSummaryDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        data["activeCount"] = this.activeCount;
        data["inactiveCount"] = this.inactiveCount;
        return data; 
    }
}

export interface IAccountSummaryDto {
    /** 账户总数 */
    totalCount?: number | undefined;
    /** 启用的账户总数 */
    activeCount?: number | undefined;
    /** 停用的账户总数 */
    inactiveCount?: number | undefined;
}

export class DistributedMapDto implements IDistributedMapDto {
    /** 经度 */
    lng?: number | undefined;
    /** 纬度 */
    lat?: number | undefined;
    /** 城市 */
    city?: string | undefined;
    /** 分布数量 */
    count?: number | undefined;

    constructor(data?: IDistributedMapDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.lng = data["lng"];
            this.lat = data["lat"];
            this.city = data["city"];
            this.count = data["count"];
        }
    }

    static fromJS(data: any): DistributedMapDto {
        data = typeof data === 'object' ? data : {};
        let result = new DistributedMapDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["lng"] = this.lng;
        data["lat"] = this.lat;
        data["city"] = this.city;
        data["count"] = this.count;
        return data; 
    }
}

export interface IDistributedMapDto {
    /** 经度 */
    lng?: number | undefined;
    /** 纬度 */
    lat?: number | undefined;
    /** 城市 */
    city?: string | undefined;
    /** 分布数量 */
    count?: number | undefined;
}

export class AccountMapDto implements IAccountMapDto {
    items?: DistributedMapDto[] | undefined;

    constructor(data?: IAccountMapDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            if (data["items"] && data["items"].constructor === Array) {
                this.items = [];
                for (let item of data["items"])
                    this.items.push(DistributedMapDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): AccountMapDto {
        data = typeof data === 'object' ? data : {};
        let result = new AccountMapDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (this.items && this.items.constructor === Array) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IAccountMapDto {
    items?: DistributedMapDto[] | undefined;
}

export class IoTSummaryDto implements IIoTSummaryDto {
    /** 设备总数 */
    totalCount?: number | undefined;
    /** 在线设备总数 */
    onlineCount?: number | undefined;
    /** 离线设备总数 */
    offlineCount?: number | undefined;

    constructor(data?: IIoTSummaryDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.totalCount = data["totalCount"];
            this.onlineCount = data["onlineCount"];
            this.offlineCount = data["offlineCount"];
        }
    }

    static fromJS(data: any): IoTSummaryDto {
        data = typeof data === 'object' ? data : {};
        let result = new IoTSummaryDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        data["onlineCount"] = this.onlineCount;
        data["offlineCount"] = this.offlineCount;
        return data; 
    }
}

export interface IIoTSummaryDto {
    /** 设备总数 */
    totalCount?: number | undefined;
    /** 在线设备总数 */
    onlineCount?: number | undefined;
    /** 离线设备总数 */
    offlineCount?: number | undefined;
}

export class IoTMapDto implements IIoTMapDto {
    items?: DistributedMapDto[] | undefined;

    constructor(data?: IIoTMapDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            if (data["items"] && data["items"].constructor === Array) {
                this.items = [];
                for (let item of data["items"])
                    this.items.push(DistributedMapDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): IoTMapDto {
        data = typeof data === 'object' ? data : {};
        let result = new IoTMapDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (this.items && this.items.constructor === Array) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IIoTMapDto {
    items?: DistributedMapDto[] | undefined;
}

export class FilterAccountsDto implements IFilterAccountsDto {
    /** 综合过滤，by name or code */
    filter?: string | undefined;
    accountGroupId?: number | undefined;
    pageIndex?: number | undefined;
    pageSize?: number | undefined;

    constructor(data?: IFilterAccountsDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.filter = data["filter"];
            this.accountGroupId = data["accountGroupId"];
            this.pageIndex = data["pageIndex"];
            this.pageSize = data["pageSize"];
        }
    }

    static fromJS(data: any): FilterAccountsDto {
        data = typeof data === 'object' ? data : {};
        let result = new FilterAccountsDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["filter"] = this.filter;
        data["accountGroupId"] = this.accountGroupId;
        data["pageIndex"] = this.pageIndex;
        data["pageSize"] = this.pageSize;
        return data; 
    }
}

export interface IFilterAccountsDto {
    /** 综合过滤，by name or code */
    filter?: string | undefined;
    accountGroupId?: number | undefined;
    pageIndex?: number | undefined;
    pageSize?: number | undefined;
}

export class CreateAccountDto implements ICreateAccountDto {
    /** 账户编号 */
    code?: string | undefined;
    /** 账户名称 */
    displayName?: string | undefined;
    password?: string | undefined;
    /** 下次登录需要修改密码 */
    needChangePasswordInNextLogin?: boolean | undefined;
    /** 邮箱 */
    email?: string | undefined;
    /** 账户是否启用 */
    isActive?: boolean | undefined;
    accountGourps?: AccountGroupDto[] | undefined;

    constructor(data?: ICreateAccountDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.code = data["code"];
            this.displayName = data["displayName"];
            this.password = data["password"];
            this.needChangePasswordInNextLogin = data["needChangePasswordInNextLogin"];
            this.email = data["email"];
            this.isActive = data["isActive"];
            if (data["accountGourps"] && data["accountGourps"].constructor === Array) {
                this.accountGourps = [];
                for (let item of data["accountGourps"])
                    this.accountGourps.push(AccountGroupDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): CreateAccountDto {
        data = typeof data === 'object' ? data : {};
        let result = new CreateAccountDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["code"] = this.code;
        data["displayName"] = this.displayName;
        data["password"] = this.password;
        data["needChangePasswordInNextLogin"] = this.needChangePasswordInNextLogin;
        data["email"] = this.email;
        data["isActive"] = this.isActive;
        if (this.accountGourps && this.accountGourps.constructor === Array) {
            data["accountGourps"] = [];
            for (let item of this.accountGourps)
                data["accountGourps"].push(item.toJSON());
        }
        return data; 
    }
}

export interface ICreateAccountDto {
    /** 账户编号 */
    code?: string | undefined;
    /** 账户名称 */
    displayName?: string | undefined;
    password?: string | undefined;
    /** 下次登录需要修改密码 */
    needChangePasswordInNextLogin?: boolean | undefined;
    /** 邮箱 */
    email?: string | undefined;
    /** 账户是否启用 */
    isActive?: boolean | undefined;
    accountGourps?: AccountGroupDto[] | undefined;
}

export class UpdateAccountDto implements IUpdateAccountDto {
    /** 账户Key */
    id?: number | undefined;
    /** 账户名称 */
    displayName?: string | undefined;
    /** 邮箱 */
    email?: string | undefined;
    /** 账户是否启用 */
    isActive?: boolean | undefined;
    accountGourps?: AccountGroupDto[] | undefined;

    constructor(data?: IUpdateAccountDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.displayName = data["displayName"];
            this.email = data["email"];
            this.isActive = data["isActive"];
            if (data["accountGourps"] && data["accountGourps"].constructor === Array) {
                this.accountGourps = [];
                for (let item of data["accountGourps"])
                    this.accountGourps.push(AccountGroupDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): UpdateAccountDto {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateAccountDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["displayName"] = this.displayName;
        data["email"] = this.email;
        data["isActive"] = this.isActive;
        if (this.accountGourps && this.accountGourps.constructor === Array) {
            data["accountGourps"] = [];
            for (let item of this.accountGourps)
                data["accountGourps"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IUpdateAccountDto {
    /** 账户Key */
    id?: number | undefined;
    /** 账户名称 */
    displayName?: string | undefined;
    /** 邮箱 */
    email?: string | undefined;
    /** 账户是否启用 */
    isActive?: boolean | undefined;
    accountGourps?: AccountGroupDto[] | undefined;
}

export class AccountListDto implements IAccountListDto {
    id?: number | undefined;
    /** 账户编号 */
    code?: string | undefined;
    /** 账户名称 */
    displayName?: string | undefined;
    /** 邮箱 */
    email?: string | undefined;
    /** 账户是否启用 */
    isActive?: boolean | undefined;
    /** 上次登录时间 */
    lastLoginTime?: number | undefined;
    /** 创建时间 */
    createTime?: number | undefined;

    constructor(data?: IAccountListDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.code = data["code"];
            this.displayName = data["displayName"];
            this.email = data["email"];
            this.isActive = data["isActive"];
            this.lastLoginTime = data["lastLoginTime"];
            this.createTime = data["createTime"];
        }
    }

    static fromJS(data: any): AccountListDto {
        data = typeof data === 'object' ? data : {};
        let result = new AccountListDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["code"] = this.code;
        data["displayName"] = this.displayName;
        data["email"] = this.email;
        data["isActive"] = this.isActive;
        data["lastLoginTime"] = this.lastLoginTime;
        data["createTime"] = this.createTime;
        return data; 
    }
}

export interface IAccountListDto {
    id?: number | undefined;
    /** 账户编号 */
    code?: string | undefined;
    /** 账户名称 */
    displayName?: string | undefined;
    /** 邮箱 */
    email?: string | undefined;
    /** 账户是否启用 */
    isActive?: boolean | undefined;
    /** 上次登录时间 */
    lastLoginTime?: number | undefined;
    /** 创建时间 */
    createTime?: number | undefined;
}

export class PagedResultDtoOfAccountsListDto implements IPagedResultDtoOfAccountsListDto {
    totalCount?: number | undefined;
    items?: AccountListDto[] | undefined;

    constructor(data?: IPagedResultDtoOfAccountsListDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.totalCount = data["totalCount"];
            if (data["items"] && data["items"].constructor === Array) {
                this.items = [];
                for (let item of data["items"])
                    this.items.push(AccountListDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfAccountsListDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfAccountsListDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (this.items && this.items.constructor === Array) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IPagedResultDtoOfAccountsListDto {
    totalCount?: number | undefined;
    items?: AccountListDto[] | undefined;
}

export class AccountGroupDto implements IAccountGroupDto {
    id?: number | undefined;
    /** 账户组名称 */
    displayName?: string | undefined;
    /** 是否是默认组 */
    isDefault?: boolean | undefined;
    /** 是否静态（系统生成），不可删除 */
    isStatic?: boolean | undefined;

    constructor(data?: IAccountGroupDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.displayName = data["displayName"];
            this.isDefault = data["isDefault"];
            this.isStatic = data["isStatic"];
        }
    }

    static fromJS(data: any): AccountGroupDto {
        data = typeof data === 'object' ? data : {};
        let result = new AccountGroupDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["displayName"] = this.displayName;
        data["isDefault"] = this.isDefault;
        data["isStatic"] = this.isStatic;
        return data; 
    }
}

export interface IAccountGroupDto {
    id?: number | undefined;
    /** 账户组名称 */
    displayName?: string | undefined;
    /** 是否是默认组 */
    isDefault?: boolean | undefined;
    /** 是否静态（系统生成），不可删除 */
    isStatic?: boolean | undefined;
}

export class ListResultDtoOfAccountGroupDto implements IListResultDtoOfAccountGroupDto {
    items?: AccountGroupDto[] | undefined;

    constructor(data?: IListResultDtoOfAccountGroupDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            if (data["items"] && data["items"].constructor === Array) {
                this.items = [];
                for (let item of data["items"])
                    this.items.push(AccountGroupDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ListResultDtoOfAccountGroupDto {
        data = typeof data === 'object' ? data : {};
        let result = new ListResultDtoOfAccountGroupDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (this.items && this.items.constructor === Array) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IListResultDtoOfAccountGroupDto {
    items?: AccountGroupDto[] | undefined;
}

export class CreateAccountGroupDto implements ICreateAccountGroupDto {
    /** 账户组名称 */
    displayName?: string | undefined;
    /** 是否是默认组 */
    isDefault?: boolean | undefined;

    constructor(data?: ICreateAccountGroupDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.displayName = data["displayName"];
            this.isDefault = data["isDefault"];
        }
    }

    static fromJS(data: any): CreateAccountGroupDto {
        data = typeof data === 'object' ? data : {};
        let result = new CreateAccountGroupDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["displayName"] = this.displayName;
        data["isDefault"] = this.isDefault;
        return data; 
    }
}

export interface ICreateAccountGroupDto {
    /** 账户组名称 */
    displayName?: string | undefined;
    /** 是否是默认组 */
    isDefault?: boolean | undefined;
}

export class UpdateAccountGroupDto implements IUpdateAccountGroupDto {
    /** 账户组名称 */
    displayName?: string | undefined;
    /** 是否是默认组 */
    isDefault?: boolean | undefined;

    constructor(data?: IUpdateAccountGroupDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.displayName = data["displayName"];
            this.isDefault = data["isDefault"];
        }
    }

    static fromJS(data: any): UpdateAccountGroupDto {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateAccountGroupDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["displayName"] = this.displayName;
        data["isDefault"] = this.isDefault;
        return data; 
    }
}

export interface IUpdateAccountGroupDto {
    /** 账户组名称 */
    displayName?: string | undefined;
    /** 是否是默认组 */
    isDefault?: boolean | undefined;
}

/** 使用中/未使用/逾期 */
export enum AppStatus {
    InUse = "InUse", 
    NotInUse = "NotInUse", 
    Overdue = "Overdue", 
}

/** 准备（下架）/出售（上架） */
export enum AppStage {
    Preparatory = "preparatory", 
    ForSale = "forSale", 
}

/** 面向所有/面向租户/面向租户组 */
export enum AppAuthorizeScope {
    All = "All", 
    ToTenants = "ToTenants", 
    ToTenantGroups = "ToTenantGroups", 
}

/** 标准版/定制版 */
export enum AppEditionType {
    Standard = "Standard", 
    Customize = "Customize", 
}

export class AppSummaryDto implements IAppSummaryDto {
    /** App总数 */
    totalCount?: number | undefined;
    /** 上架(出售)的App总数 */
    countForSale?: number | undefined;
    /** 下架(准备阶段)的App总数 */
    countInPreparatory?: number | undefined;

    constructor(data?: IAppSummaryDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.totalCount = data["totalCount"];
            this.countForSale = data["CountForSale"];
            this.countInPreparatory = data["CountInPreparatory"];
        }
    }

    static fromJS(data: any): AppSummaryDto {
        data = typeof data === 'object' ? data : {};
        let result = new AppSummaryDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        data["CountForSale"] = this.countForSale;
        data["CountInPreparatory"] = this.countInPreparatory;
        return data; 
    }
}

export interface IAppSummaryDto {
    /** App总数 */
    totalCount?: number | undefined;
    /** 上架(出售)的App总数 */
    countForSale?: number | undefined;
    /** 下架(准备阶段)的App总数 */
    countInPreparatory?: number | undefined;
}

export class AuthorizeTenantDto implements IAuthorizeTenantDto {
    tenantId?: number | undefined;
    appId?: number | undefined;
    /** 基础功能 */
    basic?: boolean | undefined;
    /** 基础功能预期时间 */
    basicExpiryTime?: number | undefined;
    /** 付费功能 */
    pay?: boolean | undefined;
    /** 付费功能预期时间 */
    payExpiryTime?: number | undefined;

    constructor(data?: IAuthorizeTenantDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.tenantId = data["tenantId"];
            this.appId = data["appId"];
            this.basic = data["basic"];
            this.basicExpiryTime = data["basicExpiryTime"];
            this.pay = data["pay"];
            this.payExpiryTime = data["payExpiryTime"];
        }
    }

    static fromJS(data: any): AuthorizeTenantDto {
        data = typeof data === 'object' ? data : {};
        let result = new AuthorizeTenantDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["tenantId"] = this.tenantId;
        data["appId"] = this.appId;
        data["basic"] = this.basic;
        data["basicExpiryTime"] = this.basicExpiryTime;
        data["pay"] = this.pay;
        data["payExpiryTime"] = this.payExpiryTime;
        return data; 
    }
}

export interface IAuthorizeTenantDto {
    tenantId?: number | undefined;
    appId?: number | undefined;
    /** 基础功能 */
    basic?: boolean | undefined;
    /** 基础功能预期时间 */
    basicExpiryTime?: number | undefined;
    /** 付费功能 */
    pay?: boolean | undefined;
    /** 付费功能预期时间 */
    payExpiryTime?: number | undefined;
}

export class TenantAppsDto implements ITenantAppsDto {
    tenant?: TenantDto | undefined;
    apps?: AppDto[] | undefined;

    constructor(data?: ITenantAppsDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.tenant = data["tenant"] ? TenantDto.fromJS(data["tenant"]) : <any>undefined;
            if (data["apps"] && data["apps"].constructor === Array) {
                this.apps = [];
                for (let item of data["apps"])
                    this.apps.push(AppDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): TenantAppsDto {
        data = typeof data === 'object' ? data : {};
        let result = new TenantAppsDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["tenant"] = this.tenant ? this.tenant.toJSON() : <any>undefined;
        if (this.apps && this.apps.constructor === Array) {
            data["apps"] = [];
            for (let item of this.apps)
                data["apps"].push(item.toJSON());
        }
        return data; 
    }
}

export interface ITenantAppsDto {
    tenant?: TenantDto | undefined;
    apps?: AppDto[] | undefined;
}

export class ListResultDtoOfAppListDto implements IListResultDtoOfAppListDto {
    items?: AppListDto[] | undefined;

    constructor(data?: IListResultDtoOfAppListDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            if (data["items"] && data["items"].constructor === Array) {
                this.items = [];
                for (let item of data["items"])
                    this.items.push(AppListDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ListResultDtoOfAppListDto {
        data = typeof data === 'object' ? data : {};
        let result = new ListResultDtoOfAppListDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (this.items && this.items.constructor === Array) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IListResultDtoOfAppListDto {
    items?: AppListDto[] | undefined;
}

export class AppListDto implements IAppListDto {
    id?: number | undefined;
    displayName?: string | undefined;
    /** 概要 */
    summary?: string | undefined;
    /** 图片地址 */
    imageUrl?: string | undefined;
    appKey?: string | undefined;
    appEditionType?: AppEditionType | undefined;
    authorizeScope?: AppAuthorizeScope | undefined;
    /** 版本号 */
    version?: string | undefined;
    appStage?: AppStage | undefined;
    /** 更新时间 */
    updateTime?: number | undefined;

    constructor(data?: IAppListDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.displayName = data["displayName"];
            this.summary = data["summary"];
            this.imageUrl = data["imageUrl"];
            this.appKey = data["appKey"];
            this.appEditionType = data["appEditionType"];
            this.authorizeScope = data["authorizeScope"];
            this.version = data["version"];
            this.appStage = data["appStage"];
            this.updateTime = data["updateTime"];
        }
    }

    static fromJS(data: any): AppListDto {
        data = typeof data === 'object' ? data : {};
        let result = new AppListDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["displayName"] = this.displayName;
        data["summary"] = this.summary;
        data["imageUrl"] = this.imageUrl;
        data["appKey"] = this.appKey;
        data["appEditionType"] = this.appEditionType;
        data["authorizeScope"] = this.authorizeScope;
        data["version"] = this.version;
        data["appStage"] = this.appStage;
        data["updateTime"] = this.updateTime;
        return data; 
    }
}

export interface IAppListDto {
    id?: number | undefined;
    displayName?: string | undefined;
    /** 概要 */
    summary?: string | undefined;
    /** 图片地址 */
    imageUrl?: string | undefined;
    appKey?: string | undefined;
    appEditionType?: AppEditionType | undefined;
    authorizeScope?: AppAuthorizeScope | undefined;
    /** 版本号 */
    version?: string | undefined;
    appStage?: AppStage | undefined;
    /** 更新时间 */
    updateTime?: number | undefined;
}

export class AppDto implements IAppDto {
    id?: number | undefined;
    displayName?: string | undefined;
    appKey?: string | undefined;
    appEditionType?: AppEditionType | undefined;
    status?: AppStatus | undefined;
    /** 基础功能 */
    basic?: boolean | undefined;
    /** 基础功能预期时间 */
    basicExpiryTime?: number | undefined;
    /** 付费功能 */
    pay?: boolean | undefined;
    /** 付费功能预期时间 */
    payExpiryTime?: number | undefined;

    constructor(data?: IAppDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.displayName = data["displayName"];
            this.appKey = data["appKey"];
            this.appEditionType = data["appEditionType"];
            this.status = data["status"];
            this.basic = data["basic"];
            this.basicExpiryTime = data["basicExpiryTime"];
            this.pay = data["pay"];
            this.payExpiryTime = data["payExpiryTime"];
        }
    }

    static fromJS(data: any): AppDto {
        data = typeof data === 'object' ? data : {};
        let result = new AppDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["displayName"] = this.displayName;
        data["appKey"] = this.appKey;
        data["appEditionType"] = this.appEditionType;
        data["status"] = this.status;
        data["basic"] = this.basic;
        data["basicExpiryTime"] = this.basicExpiryTime;
        data["pay"] = this.pay;
        data["payExpiryTime"] = this.payExpiryTime;
        return data; 
    }
}

export interface IAppDto {
    id?: number | undefined;
    displayName?: string | undefined;
    appKey?: string | undefined;
    appEditionType?: AppEditionType | undefined;
    status?: AppStatus | undefined;
    /** 基础功能 */
    basic?: boolean | undefined;
    /** 基础功能预期时间 */
    basicExpiryTime?: number | undefined;
    /** 付费功能 */
    pay?: boolean | undefined;
    /** 付费功能预期时间 */
    payExpiryTime?: number | undefined;
}

export class ListResultDtoOfAppDto implements IListResultDtoOfAppDto {
    items?: AppDto[] | undefined;

    constructor(data?: IListResultDtoOfAppDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            if (data["items"] && data["items"].constructor === Array) {
                this.items = [];
                for (let item of data["items"])
                    this.items.push(AppDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ListResultDtoOfAppDto {
        data = typeof data === 'object' ? data : {};
        let result = new ListResultDtoOfAppDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (this.items && this.items.constructor === Array) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IListResultDtoOfAppDto {
    items?: AppDto[] | undefined;
}

export class TenantDto implements ITenantDto {
    /** 租户key */
    id?: number | undefined;
    /** 租户编号 */
    code?: string | undefined;
    /** 租户名称 */
    displayName?: string | undefined;
    /** 租户描述 */
    desc?: string | undefined;
    /** 租户过期时间 */
    expiryTime?: number | undefined;
    /** 是否激活租户 */
    isActive?: boolean | undefined;

    constructor(data?: ITenantDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.code = data["code"];
            this.displayName = data["displayName"];
            this.desc = data["desc"];
            this.expiryTime = data["expiryTime"];
            this.isActive = data["isActive"];
        }
    }

    static fromJS(data: any): TenantDto {
        data = typeof data === 'object' ? data : {};
        let result = new TenantDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["code"] = this.code;
        data["displayName"] = this.displayName;
        data["desc"] = this.desc;
        data["expiryTime"] = this.expiryTime;
        data["isActive"] = this.isActive;
        return data; 
    }
}

export interface ITenantDto {
    /** 租户key */
    id?: number | undefined;
    /** 租户编号 */
    code?: string | undefined;
    /** 租户名称 */
    displayName?: string | undefined;
    /** 租户描述 */
    desc?: string | undefined;
    /** 租户过期时间 */
    expiryTime?: number | undefined;
    /** 是否激活租户 */
    isActive?: boolean | undefined;
}

export class TenantSummaryDto implements ITenantSummaryDto {
    /** 租户总数 */
    totalCount?: number | undefined;
    /** 启用的租户总数 */
    activeCount?: number | undefined;
    /** 停用的租户总数 */
    inactiveCount?: number | undefined;

    constructor(data?: ITenantSummaryDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.totalCount = data["totalCount"];
            this.activeCount = data["activeCount"];
            this.inactiveCount = data["inactiveCount"];
        }
    }

    static fromJS(data: any): TenantSummaryDto {
        data = typeof data === 'object' ? data : {};
        let result = new TenantSummaryDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        data["activeCount"] = this.activeCount;
        data["inactiveCount"] = this.inactiveCount;
        return data; 
    }
}

export interface ITenantSummaryDto {
    /** 租户总数 */
    totalCount?: number | undefined;
    /** 启用的租户总数 */
    activeCount?: number | undefined;
    /** 停用的租户总数 */
    inactiveCount?: number | undefined;
}

export class CreateTenantDto implements ICreateTenantDto {
    /** 租户编号 */
    code!: string;
    /** 租户名称 */
    displayName!: string;
    /** 租户描述 */
    desc?: string | undefined;
    /** 租户管理员邮箱 */
    adminEmail!: string;
    adminPassword!: string;
    /** 下次登录时密码重置 */
    shouldChangePasswordOnNextLogin?: boolean | undefined;
    /** 是否激活租户 */
    isActive?: boolean | undefined;
    /** 租户过期时间 */
    expiryTime?: number | undefined;

    constructor(data?: ICreateTenantDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.code = data["code"];
            this.displayName = data["displayName"];
            this.desc = data["desc"];
            this.adminEmail = data["adminEmail"];
            this.adminPassword = data["adminPassword"];
            this.shouldChangePasswordOnNextLogin = data["shouldChangePasswordOnNextLogin"];
            this.isActive = data["isActive"];
            this.expiryTime = data["expiryTime"];
        }
    }

    static fromJS(data: any): CreateTenantDto {
        data = typeof data === 'object' ? data : {};
        let result = new CreateTenantDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["code"] = this.code;
        data["displayName"] = this.displayName;
        data["desc"] = this.desc;
        data["adminEmail"] = this.adminEmail;
        data["adminPassword"] = this.adminPassword;
        data["shouldChangePasswordOnNextLogin"] = this.shouldChangePasswordOnNextLogin;
        data["isActive"] = this.isActive;
        data["expiryTime"] = this.expiryTime;
        return data; 
    }
}

export interface ICreateTenantDto {
    /** 租户编号 */
    code: string;
    /** 租户名称 */
    displayName: string;
    /** 租户描述 */
    desc?: string | undefined;
    /** 租户管理员邮箱 */
    adminEmail: string;
    adminPassword: string;
    /** 下次登录时密码重置 */
    shouldChangePasswordOnNextLogin?: boolean | undefined;
    /** 是否激活租户 */
    isActive?: boolean | undefined;
    /** 租户过期时间 */
    expiryTime?: number | undefined;
}

export class UpdateTenantDto implements IUpdateTenantDto {
    /** 租户名称 */
    displayName?: string | undefined;
    /** 租户描述 */
    desc?: string | undefined;
    /** 是否激活租户 */
    isActive!: boolean;
    /** 租户过期时间 */
    expiryTime?: number | undefined;

    constructor(data?: IUpdateTenantDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.displayName = data["displayName"];
            this.desc = data["desc"];
            this.isActive = data["isActive"];
            this.expiryTime = data["expiryTime"];
        }
    }

    static fromJS(data: any): UpdateTenantDto {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateTenantDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["displayName"] = this.displayName;
        data["desc"] = this.desc;
        data["isActive"] = this.isActive;
        data["expiryTime"] = this.expiryTime;
        return data; 
    }
}

export interface IUpdateTenantDto {
    /** 租户名称 */
    displayName?: string | undefined;
    /** 租户描述 */
    desc?: string | undefined;
    /** 是否激活租户 */
    isActive: boolean;
    /** 租户过期时间 */
    expiryTime?: number | undefined;
}

export class PagedResultDtoOfTenantListDto implements IPagedResultDtoOfTenantListDto {
    totalCount?: number | undefined;
    items?: TenantListDto[] | undefined;

    constructor(data?: IPagedResultDtoOfTenantListDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.totalCount = data["totalCount"];
            if (data["items"] && data["items"].constructor === Array) {
                this.items = [];
                for (let item of data["items"])
                    this.items.push(TenantListDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfTenantListDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfTenantListDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (this.items && this.items.constructor === Array) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IPagedResultDtoOfTenantListDto {
    totalCount?: number | undefined;
    items?: TenantListDto[] | undefined;
}

export class TenantListDto implements ITenantListDto {
    id?: number | undefined;
    code?: string | undefined;
    name?: string | undefined;
    isActive?: boolean | undefined;
    /** 创建时间 */
    createTime?: number | undefined;
    /** 过期时间 */
    expiryTime?: number | undefined;

    constructor(data?: ITenantListDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.code = data["code"];
            this.name = data["name"];
            this.isActive = data["isActive"];
            this.createTime = data["createTime"];
            this.expiryTime = data["expiryTime"];
        }
    }

    static fromJS(data: any): TenantListDto {
        data = typeof data === 'object' ? data : {};
        let result = new TenantListDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["code"] = this.code;
        data["name"] = this.name;
        data["isActive"] = this.isActive;
        data["createTime"] = this.createTime;
        data["expiryTime"] = this.expiryTime;
        return data; 
    }
}

export interface ITenantListDto {
    id?: number | undefined;
    code?: string | undefined;
    name?: string | undefined;
    isActive?: boolean | undefined;
    /** 创建时间 */
    createTime?: number | undefined;
    /** 过期时间 */
    expiryTime?: number | undefined;
}

export class FilterTenantsDto implements IFilterTenantsDto {
    filter?: string | undefined;
    tenantCode?: string | undefined;
    tenantName?: string | undefined;
    appId?: number | undefined;
    createDateStart?: number | undefined;
    createDateEnd?: number | undefined;
    pageIndex?: number | undefined;
    pageSize?: number | undefined;

    constructor(data?: IFilterTenantsDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.filter = data["filter"];
            this.tenantCode = data["tenantCode"];
            this.tenantName = data["tenantName"];
            this.appId = data["appId"];
            this.createDateStart = data["createDateStart"];
            this.createDateEnd = data["createDateEnd"];
            this.pageIndex = data["pageIndex"];
            this.pageSize = data["pageSize"];
        }
    }

    static fromJS(data: any): FilterTenantsDto {
        data = typeof data === 'object' ? data : {};
        let result = new FilterTenantsDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["filter"] = this.filter;
        data["tenantCode"] = this.tenantCode;
        data["tenantName"] = this.tenantName;
        data["appId"] = this.appId;
        data["createDateStart"] = this.createDateStart;
        data["createDateEnd"] = this.createDateEnd;
        data["pageIndex"] = this.pageIndex;
        data["pageSize"] = this.pageSize;
        return data; 
    }
}

export interface IFilterTenantsDto {
    filter?: string | undefined;
    tenantCode?: string | undefined;
    tenantName?: string | undefined;
    appId?: number | undefined;
    createDateStart?: number | undefined;
    createDateEnd?: number | undefined;
    pageIndex?: number | undefined;
    pageSize?: number | undefined;
}

export class AuthenticateResultModel implements IAuthenticateResultModel {
    /** 授权Token */
    accessToken?: string | undefined;
    /** 有效时长 */
    expireInSeconds?: number | undefined;
    /** 是否需要重置密码 */
    shouldResetPassword?: boolean | undefined;
    /** 如果需要重置密码，生成ResetCode后返回前端 */
    passwordResetCode?: string | undefined;
    userId?: number | undefined;
    returnUrl?: string | undefined;

    constructor(data?: IAuthenticateResultModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.accessToken = data["accessToken"];
            this.expireInSeconds = data["expireInSeconds"];
            this.shouldResetPassword = data["shouldResetPassword"];
            this.passwordResetCode = data["passwordResetCode"];
            this.userId = data["userId"];
            this.returnUrl = data["returnUrl"];
        }
    }

    static fromJS(data: any): AuthenticateResultModel {
        data = typeof data === 'object' ? data : {};
        let result = new AuthenticateResultModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["accessToken"] = this.accessToken;
        data["expireInSeconds"] = this.expireInSeconds;
        data["shouldResetPassword"] = this.shouldResetPassword;
        data["passwordResetCode"] = this.passwordResetCode;
        data["userId"] = this.userId;
        data["returnUrl"] = this.returnUrl;
        return data; 
    }
}

export interface IAuthenticateResultModel {
    /** 授权Token */
    accessToken?: string | undefined;
    /** 有效时长 */
    expireInSeconds?: number | undefined;
    /** 是否需要重置密码 */
    shouldResetPassword?: boolean | undefined;
    /** 如果需要重置密码，生成ResetCode后返回前端 */
    passwordResetCode?: string | undefined;
    userId?: number | undefined;
    returnUrl?: string | undefined;
}

export class AuthenticateModel implements IAuthenticateModel {
    tenantCode?: string | undefined;
    /** 用户名 */
    userName!: string;
    password!: string;
    rememberClient?: boolean | undefined;
    /** 未登录时访问的页面，登录后需要重定向 */
    returnUrl?: string | undefined;

    constructor(data?: IAuthenticateModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.tenantCode = data["tenantCode"];
            this.userName = data["userName"];
            this.password = data["password"];
            this.rememberClient = data["rememberClient"];
            this.returnUrl = data["returnUrl"];
        }
    }

    static fromJS(data: any): AuthenticateModel {
        data = typeof data === 'object' ? data : {};
        let result = new AuthenticateModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["tenantCode"] = this.tenantCode;
        data["userName"] = this.userName;
        data["password"] = this.password;
        data["rememberClient"] = this.rememberClient;
        data["returnUrl"] = this.returnUrl;
        return data; 
    }
}

export interface IAuthenticateModel {
    tenantCode?: string | undefined;
    /** 用户名 */
    userName: string;
    password: string;
    rememberClient?: boolean | undefined;
    /** 未登录时访问的页面，登录后需要重定向 */
    returnUrl?: string | undefined;
}

export class ListResultDtoOfNameValueDto implements IListResultDtoOfNameValueDto {
    items?: NameValueDto[] | undefined;

    constructor(data?: IListResultDtoOfNameValueDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            if (data["items"] && data["items"].constructor === Array) {
                this.items = [];
                for (let item of data["items"])
                    this.items.push(NameValueDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ListResultDtoOfNameValueDto {
        data = typeof data === 'object' ? data : {};
        let result = new ListResultDtoOfNameValueDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (this.items && this.items.constructor === Array) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IListResultDtoOfNameValueDto {
    items?: NameValueDto[] | undefined;
}

export class NameValueDto implements INameValueDto {
    name?: string | undefined;
    value?: string | undefined;

    constructor(data?: INameValueDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.name = data["name"];
            this.value = data["value"];
        }
    }

    static fromJS(data: any): NameValueDto {
        data = typeof data === 'object' ? data : {};
        let result = new NameValueDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["value"] = this.value;
        return data; 
    }
}

export interface INameValueDto {
    name?: string | undefined;
    value?: string | undefined;
}

export class PageSearchDto implements IPageSearchDto {
    pageSize?: number | undefined;
    pageIndex?: number | undefined;

    constructor(data?: IPageSearchDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.pageSize = data["pageSize"];
            this.pageIndex = data["pageIndex"];
        }
    }

    static fromJS(data: any): PageSearchDto {
        data = typeof data === 'object' ? data : {};
        let result = new PageSearchDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["pageSize"] = this.pageSize;
        data["pageIndex"] = this.pageIndex;
        return data; 
    }
}

export interface IPageSearchDto {
    pageSize?: number | undefined;
    pageIndex?: number | undefined;
}

export interface FileParameter {
    data: any;
    fileName: string;
}

export class SwaggerException extends Error {
    message: string;
    status: number; 
    response: string; 
    headers: { [key: string]: any; };
    result: any; 

    constructor(message: string, status: number, response: string, headers: { [key: string]: any; }, result: any) {
        super();

        this.message = message;
        this.status = status;
        this.response = response;
        this.headers = headers;
        this.result = result;
    }

    protected isSwaggerException = true;

    static isSwaggerException(obj: any): obj is SwaggerException {
        return obj.isSwaggerException === true;
    }
}

function throwException(message: string, status: number, response: string, headers: { [key: string]: any; }, result?: any): Observable<any> {
    if(result !== null && result !== undefined)
        return _observableThrow(result);
    else
        return _observableThrow(new SwaggerException(message, status, response, headers, null));
}

function blobToText(blob: any): Observable<string> {
    return new Observable<string>((observer: any) => {
        if (!blob) {
            observer.next("");
            observer.complete();
        } else {
            let reader = new FileReader(); 
            reader.onload = event => { 
                observer.next((<any>event.target).result);
                observer.complete();
            };
            reader.readAsText(blob); 
        }
    });
}

// additional code need to integrate into service proxies
// code here will be add in the end of service proxies file
// ----------------------